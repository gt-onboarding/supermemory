---
title: "Sistema de Perguntas e Respostas sobre documents"
description: "Crie um chatbot que responda a perguntas a partir dos seus documents, com citações e referências às fontes"
---

Crie um sistema robusto de perguntas e respostas sobre documents que possa ingerir PDFs, arquivos de texto e páginas da web e, em seguida, responder a perguntas com citações precisas. Perfeito para sites de documentação, bases de pesquisa ou bases de conhecimento internas.

<div id="what-youll-build">
  ## O que você vai construir
</div>

Um sistema de perguntas e respostas sobre documentos que:

- **Ingere vários tipos de arquivo** (PDFs, DOCX, texto, URLs)
- **Responde a perguntas com precisão** e inclui citações das fontes
- **Fornece referências às fontes** com números de página e títulos dos documentos
- **Lida com perguntas de seguimento** usando o contexto da conversa
- **Suporta várias coleções de documentos** para diferentes tópicos

<div id="prerequisites">
  ## Pré-requisitos
</div>

- Node.js 18+ ou Python 3.8+
- Chave da API da Supermemory
- Chave da API da OpenAI
- Noções básicas de manipulação de arquivos

<div id="implementation">
  ## Implementação
</div>

<div id="step-1-document-processing-system">
  ### Etapa 1: Sistema de Processamento de Documentos
</div>

<Tabs>
  <Tab title="Next.js">
    ```typescript lib/document-processor.ts
    import { Supermemory } from 'supermemory'

    const client = new Supermemory({
      apiKey: process.env.SUPERMEMORY_API_KEY!
    })

    interface DocumentUpload {
      file: File
      collection: string
      metadata?: Record<string, any>
    }

    export class DocumentProcessor {
      async uploadDocument({ file, collection, metadata = {} }: DocumentUpload) {
        try {
          const formData = new FormData()
          formData.append('file', file)
          formData.append('containerTags', JSON.stringify([collection]))
          formData.append('metadata', JSON.stringify({
            originalName: file.name,
            fileType: file.type,
            uploadedAt: new Date().toISOString(),
            ...metadata
          }))

          const response = await fetch('/api/upload-document', {
            method: 'POST',
            body: formData
          })

          if (!response.ok) {
            throw new Error(`Falha no upload: ${response.statusText}`)
          }

          return await response.json()
        } catch (error) {
          console.error('Erro no upload do documento:', error)
          throw error
        }
      }

      async uploadURL({ url, collection, metadata = {} }: { url: string, collection: string, metadata?: Record<string, any> }) {
        try {
          const result = await client.memories.add({
            content: url,
            containerTag: collection,
            metadata: {
              type: 'url',
              originalUrl: url,
              uploadedAt: new Date().toISOString(),
              ...metadata
            }
          })

          return result
        } catch (error) {
          console.error('Erro no upload da URL:', error)
          throw error
        }
      }

      async getDocumentStatus(documentId: string) {
        try {
          const memory = await client.memories.get(documentId)
          return {
            id: memory.id,
            status: memory.status,
            title: memory.title,
            progress: memory.metadata?.progress || 0
          }
        } catch (error) {
          console.error('Erro na verificação de status:', error)
          throw error
        }
      }

      async listDocuments(collection: string) {
        try {
          const memories = await client.memories.list({
            containerTags: [collection],
            limit: 50,
            sort: 'updatedAt',
            order: 'desc'
          })

          return memories.memories.map(memory => ({
            id: memory.id,
            title: memory.title || memory.metadata?.originalName || 'Sem título',
            type: memory.metadata?.fileType || memory.metadata?.type || 'desconhecido',
            uploadedAt: memory.metadata?.uploadedAt,
            status: memory.status,
            url: memory.metadata?.originalUrl
          }))
        } catch (error) {
          console.error('Erro ao listar documentos:', error)
          throw error
        }
      }
    }
    ```

    ```typescript app/api/upload-document/route.ts
    import { NextRequest, NextResponse } from 'next/server'
    import { Supermemory } from 'supermemory'

    const client = new Supermemory({
      apiKey: process.env.SUPERMEMORY_API_KEY!
    })

    export async function POST(request: NextRequest) {
      try {
        const formData = await request.formData()
        const file = formData.get('file') as File
        const containerTags = JSON.parse(formData.get('containerTags') as string)
        const metadata = JSON.parse(formData.get('metadata') as string || '{}')

        if (!file) {
          return NextResponse.json({ error: 'Nenhum arquivo foi fornecido' }, { status: 400 })
        }

        // Converter File em Buffer para o Supermemory
        const bytes = await file.arrayBuffer()
        const buffer = Buffer.from(bytes)

        const result = await client.memories.uploadFile({
          file: buffer,
          filename: file.name,
          containerTags,
          metadata
        })

        return NextResponse.json({
          success: true,
          documentId: result.id,
          message: 'Documento carregado com sucesso'
        })

      } catch (error) {
        console.error('Erro no upload:', error)
        return NextResponse.json(
          { error: 'Falha no upload', details: error.message },
          { status: 500 }
        )
      }
    }
    ```
  </Tab>

  <Tab title="Python">
    ```python document_processor.py
    from supermemory import Supermemory
    import os
    from typing import Dict, List, Any, Optional
    import requests
    from datetime import datetime

    class DocumentProcessor:
        def __init__(self):
            self.client = Supermemory(api_key=os.getenv("SUPERMEMORY_API_KEY"))

        def upload_file(self, file_path: str, collection: str, metadata: Dict[str, Any] = None) -> Dict:
            """Enviar um arquivo local para o Supermemory"""
            if metadata is None:
                metadata = {}

            try:
                with open(file_path, 'rb') as file:
                    result = self.client.memories.upload_file(
                        file=file,
                        container_tags=[collection],
                        metadata={
                            'originalName': os.path.basename(file_path),
                            'fileType': os.path.splitext(file_path)[1],
                            'uploadedAt': datetime.now().isoformat(),
                            **metadata
                        }
                    )
                return result
            except Exception as e:
                print(f"Erro ao enviar arquivo: {e}")
                raise

        def upload_url(self, url: str, collection: str, metadata: Dict[str, Any] = None) -> Dict:
            """Enviar conteúdo de uma URL para o Supermemory"""
            if metadata is None:
                metadata = {}

            try:
                result = self.client.memories.add(
                    content=url,
                    container_tag=collection,
                    metadata={
                        'type': 'url',
                        'originalUrl': url,
                        'uploadedAt': datetime.now().isoformat(),
                        **metadata
                    }
                )
                return result
            except Exception as e:
                print(f"Erro ao enviar URL: {e}")
                raise

        def get_document_status(self, document_id: str) -> Dict:
            """Verificar o status de processamento do documento"""
            try:
                memory = self.client.memories.get(document_id)
                return {
                    'id': memory.id,
                    'status': memory.status,
                    'title': memory.title,
                    'progress': memory.metadata.get('progress', 0) if memory.metadata else 0
                }
            except Exception as e:
                print(f"Erro ao verificar status: {e}")
                raise

        def list_documents(self, collection: str) -> List[Dict]:
            """Listar todos os documents em uma coleção"""
            try:
                memories = self.client.memories.list(
                    container_tags=[collection],
                    limit=50,
                    sort='updatedAt',
                    order='desc'
                )

                return [
                    {
                        'id': memory.id,
                        'title': (memory.title or
                                memory.metadata.get('originalName') or
                                'Sem título' if memory.metadata else 'Sem título'),
                        'type': (memory.metadata.get('fileType') or
                               memory.metadata.get('type') or
                               'desconhecido' if memory.metadata else 'desconhecido'),
                        'uploadedAt': memory.metadata.get('uploadedAt') if memory.metadata else None,
                        'status': memory.status,
                        'url': memory.metadata.get('originalUrl') if memory.metadata else None
                    }
                    for memory in memories.memories
                ]
            except Exception as e:
                print(f"Erro ao listar documents: {e}")
                raise
    ```
  </Tab>
</Tabs>

<div id="step-2-qa-api-with-citations">
  ### Etapa 2: API de Perguntas e Respostas com citações
</div>

<Tabs>
  <Tab title="Rota de API do Next.js">
    ```typescript app/api/qa/route.ts
    import { streamText } from 'ai'
    import { createOpenAI } from '@ai-sdk/openai'
    import { Supermemory } from 'supermemory'

    const openai = createOpenAI({
      apiKey: process.env.OPENAI_API_KEY!
    })

    const client = new Supermemory({
      apiKey: process.env.SUPERMEMORY_API_KEY!
    })

    export async function POST(request: Request) {
      const { question, collection, conversationHistory = [] } = await request.json()

      try {
        // Buscar documentos relevantes
        const searchResults = await client.search.documents({
          q: question,
          containerTags: [collection],
          limit: 8,
          rerank: true,
          includeFullDocs: false,
          includeSummary: true,
          onlyMatchingChunks: false,
          documentThreshold: 0.6,
          chunkThreshold: 0.7
        })

        if (searchResults.results.length === 0) {
          return Response.json({
            answer: "Não consegui encontrar informações relevantes nos documentos carregados para responder à sua pergunta.",
            sources: [],
            confidence: 0
          })
        }

        // Preparar contexto a partir dos resultados da busca
        const context = searchResults.results.map((result, index) => {
          const chunks = result.chunks
            .filter(chunk => chunk.isRelevant)
            .slice(0, 3)
            .map(chunk => chunk.content)
            .join('\n\n')

          return `[Documento ${index + 1}: "${result.title}"]\n${chunks}`
        }).join('\n\n---\n\n')

        // Preparar fontes para citação
        const sources = searchResults.results.map((result, index) => ({
          id: result.documentId,
          title: result.title,
          type: result.type,
          relevantChunks: result.chunks.filter(chunk => chunk.isRelevant).length,
          score: result.score,
          citationNumber: index + 1
        }))

        const messages = [
          ...conversationHistory,
          {
            role: 'user' as const,
            content: question
          }
        ]

        const result = await streamText({
          model: openai('gpt-5'),
          messages,
          system: `Você é um assistente útil de perguntas e respostas sobre documentos. Responda às perguntas baseando-se APENAS no contexto dos documentos fornecidos.

    CONTEXTO DOS DOCUMENTOS:
    ${context}

    INSTRUÇÕES:
    1. Responda à pergunta usando APENAS as informações dos documentos fornecidos
    2. Inclua citações específicas em sua resposta usando o formato [Documento X]
    3. Se os documentos não contiverem informações suficientes, deixe isso claro
    4. Seja preciso e cite diretamente quando possível
    5. Se múltiplos documentos apoiarem um ponto, cite todos os relevantes
    6. Mantenha um tom útil e profissional

    FORMATO DE CITAÇÃO:
    - Use [Documento 1], [Documento 2], etc. para citar fontes
    - Coloque citações após a informação relevante
    - Exemplo: "O processo envolve três etapas [Documento 1]. No entanto, alguns especialistas recomendam uma abordagem de quatro etapas [Documento 3]."

    Se a pergunta não puder ser respondida com base nos documentos fornecidos, responda com: "Não tenho informações suficientes nos documentos fornecidos para responder a esta pergunta com precisão."`,
          temperature: 0.1,
          maxTokens: 1000
        })

        return result.toAIStreamResponse({
          data: {
            sources,
            searchResultsCount: searchResults.results.length,
            totalResults: searchResults.total
          }
        })

      } catch (error) {
        console.error('Erro de Q&A:', error)
        return Response.json(
          { error: 'Falha ao processar pergunta', details: error.message },
          { status: 500 }
        )
      }
    }
    ```
  </Tab>

  <Tab title="Python (FastAPI)">
    ```python qa_api.py
    from fastapi import FastAPI, HTTPException
    from fastapi.responses import StreamingResponse
    from pydantic import BaseModel
    from typing import List, Dict, Any, Optional
    import openai
    from supermemory import Supermemory
    import json
    import os

    app = FastAPI()

    openai_client = openai.AsyncOpenAI(api_key=os.getenv("OPENAI_API_KEY"))
    supermemory_client = Supermemory(api_key=os.getenv("SUPERMEMORY_API_KEY"))

    class QARequest(BaseModel):
        question: str
        collection: str
        conversationHistory: List[Dict[str, str]] = []

    class QAResponse(BaseModel):
        answer: str
        sources: List[Dict[str, Any]]
        confidence: float
        searchResultsCount: int

    @app.post("/qa")
    async def answer_question(request: QARequest):
        try:
            # Buscar por documentos relevantes
            search_results = supermemory_client.search.documents(
                q=request.question,
                container_tags=[request.collection],
                limit=8,
                rerank=True,
                include_full_docs=False,
                include_summary=True,
                only_matching_chunks=False,
                document_threshold=0.6,
                chunk_threshold=0.7
            )

            if not search_results.results:
                return QAResponse(
                    answer="Não consegui encontrar informações relevantes nos documentos enviados para responder sua pergunta.",
                    sources=[],
                    confidence=0,
                    searchResultsCount=0
                )

            # Preparar contexto dos resultados da busca
            context_parts = []
            sources = []

            for index, result in enumerate(search_results.results):
                relevant_chunks = [
                    chunk.content for chunk in result.chunks
                    if chunk.is_relevant
                ][:3]

                chunk_text = '\n\n'.join(relevant_chunks)
                context_parts.append(f'[Document {index + 1}: "{result.title}"]\n{chunk_text}')

                sources.append({
                    'id': result.document_id,
                    'title': result.title,
                    'type': result.type,
                    'relevantChunks': len([c for c in result.chunks if c.is_relevant]),
                    'score': result.score,
                    'citationNumber': index + 1
                })

            context = '\n\n---\n\n'.join(context_parts)

            # Preparar mensagens
            messages = [
                {
                    "role": "system",
                    "content": f"""Você é um assistente útil de perguntas e respostas sobre documentos. Responda perguntas baseado APENAS no contexto dos documentos fornecidos.

    CONTEXTO DOS DOCUMENTOS:
    {context}

    INSTRUÇÕES:
    1. Responda a pergunta usando APENAS as informações dos documentos fornecidos
    2. Inclua citações específicas em sua resposta usando o formato [Document X]
    3. Se os documentos não contiverem informações suficientes, diga isso claramente
    4. Seja preciso e cite diretamente quando possível
    5. Se múltiplos documentos apoiarem um ponto, cite todos os relevantes
    6. Mantenha um tom útil e profissional

    FORMATO DE CITAÇÃO:
    - Use [Document 1], [Document 2], etc. para citar fontes
    - Coloque citações após a informação relevante
    - Exemplo: "O processo envolve três etapas [Document 1]. No entanto, alguns especialistas recomendam uma abordagem de quatro etapas [Document 3]."

    Se a pergunta não puder ser respondida a partir dos documentos fornecidos, responda com: "Não tenho informações suficientes nos documentos fornecidos para responder esta pergunta com precisão." """
                }
            ]

            # Adicionar histórico da conversa
            messages.extend(request.conversationHistory)
            messages.append({"role": "user", "content": request.question})

            # Obter resposta da IA
            response = await openai_client.chat.completions.create(
                model="gpt-5",
                messages=messages,
                temperature=0.1,
                max_tokens=1000
            )

            answer = response.choices[0].message.content

            return QAResponse(
                answer=answer,
                sources=sources,
                confidence=min(search_results.results[0].score if search_results.results else 0, 1.0),
                searchResultsCount=len(search_results.results)
            )

        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Falha ao processar pergunta: {str(e)}")

    if __name__ == "__main__":
        import uvicorn
        uvicorn.run(app, host="0.0.0.0", port=8000)
    ```
  </Tab>
</Tabs>

<div id="step-3-frontend-interface">
  ### Etapa 3: Interface do front-end
</div>

```tsx app/qa/page.tsx
'use client'

import { useState, useRef } from 'react'
import { useChat } from 'ai/react'
import { DocumentProcessor } from '@/lib/document-processor'

interface Document {
  id: string
  title: string
  type: string
  status: string
  uploadedAt: string
}

interface Source {
  id: string
  title: string
  citationNumber: number
  score: number
  relevantChunks: number
}

export default function DocumentQA() {
  const [collection, setCollection] = useState('default-docs')
  const [documents, setDocuments] = useState<Document[]>([])
  const [sources, setSources] = useState<Source[]>([])
  const [isUploading, setIsUploading] = useState(false)
  const [uploadProgress, setUploadProgress] = useState<Record<string, number>>({})
  const fileInputRef = useRef<HTMLInputElement>(null)

  const processor = new DocumentProcessor()

  const { messages, input, handleInputChange, handleSubmit, isLoading } = useChat({
    api: '/api/qa',
    body: {
      collection
    },
    onFinish: (message, { data }) => {
      if (data?.sources) {
        setSources(data.sources)
      }
    }
  })

  const handleFileUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const files = event.target.files
    if (!files || files.length === 0) return

    setIsUploading(true)
    const newProgress: Record<string, number> = {}

    try {
      for (const file of Array.from(files)) {
        newProgress[file.name] = 0
        setUploadProgress({ ...newProgress })

        await processor.uploadDocument({
          file,
          collection,
          metadata: {
            uploadedBy: 'user',
            category: 'qa-document'
          }
        })

        newProgress[file.name] = 100
        setUploadProgress({ ...newProgress })
      }

      // Refresh document list
      await loadDocuments()

      // Clear file input
      if (fileInputRef.current) {
        fileInputRef.current.value = ''
      }

    } catch (error) {
      console.error('Upload failed:', error)
      alert('Upload failed: ' + error.message)
    } finally {
      setIsUploading(false)
      setUploadProgress({})
    }
  }

  const loadDocuments = async () => {
    try {
      const docs = await processor.listDocuments(collection)
      setDocuments(docs)
    } catch (error) {
      console.error('Failed to load documents:', error)
    }
  }

  const formatSources = (sources: Source[]) => {
    if (!sources || sources.length === 0) return null

    return (
      <div className="mt-4 p-4 bg-gray-50 border border-gray-200 rounded-lg">
        <h3 className="text-sm font-semibold text-gray-700 mb-2">Fontes:</h3>
        <div className="space-y-2">
          {sources.map((source) => (
            <div key={source.id} className="flex items-center space-x-2 text-sm">
              <span className="bg-blue-100 text-blue-800 px-2 py-1 rounded text-xs font-mono">
                Documento {source.citationNumber}
              </span>
              <span className="text-gray-700">{source.title}</span>
              <span className="text-gray-500">
                ({source.relevantChunks} chunks relevantes, {(source.score * 100).toFixed(1)}% de correspondência)
              </span>
            </div>
          ))}
        </div>
      </div>
    )
  }

  return (
    <div className="max-w-6xl mx-auto p-6">
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* Document Management Panel */}
        <div className="lg:col-span-1">
          <div className="bg-white border border-gray-200 rounded-lg p-6">
            <h2 className="text-lg font-semibold mb-4">Coleção de Documents</h2>

            {/* Collection Selector */}
            <div className="mb-4">
              <label className="block text-sm font-medium text-gray-700 mb-2">
                Nome da Coleção
              </label>
              <input
                type="text"
                value={collection}
                onChange={(e) => setCollection(e.target.value)}
                className="w-full p-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                placeholder="ex: docs-empresa"
              />
            </div>

            {/* File Upload */}
            <div className="mb-4">
              <input
                ref={fileInputRef}
                type="file"
                multiple
                accept=".pdf,.docx,.txt,.md"
                onChange={handleFileUpload}
                className="hidden"
              />
              <button
                onClick={() => fileInputRef.current?.click()}
                disabled={isUploading}
                className="w-full p-3 border-2 border-dashed border-gray-300 rounded-lg hover:border-blue-400 focus:ring-2 focus:ring-blue-500 disabled:opacity-50"
              >
                {isUploading ? 'Enviando...' : 'Enviar Documents'}
              </button>
            </div>

            {/* Upload Progress */}
            {Object.keys(uploadProgress).length > 0 && (
              <div className="mb-4 space-y-2">
                {Object.entries(uploadProgress).map(([filename, progress]) => (
                  <div key={filename} className="text-sm">
                    <div className="flex justify-between">
                      <span className="truncate">{filename}</span>
                      <span>{progress}%</span>
                    </div>
                    <div className="w-full bg-gray-200 rounded-full h-2">
                      <div
                        className="bg-blue-600 h-2 rounded-full transition-all duration-300"
                        style={{ width: `${progress}%` }}
                      />
                    </div>
                  </div>
                ))}
              </div>
            )}

            {/* Document List */}
            <div className="max-h-64 overflow-y-auto">
              {documents.map((doc) => (
                <div key={doc.id} className="mb-2 p-2 bg-gray-50 rounded text-sm">
                  <div className="font-medium truncate">{doc.title}</div>
                  <div className="text-gray-500 text-xs">
                    {doc.type} • {doc.status}
                  </div>
                </div>
              ))}
            </div>

            <button
              onClick={loadDocuments}
              className="w-full mt-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
            >
              Atualizar Documents
            </button>
          </div>
        </div>

        {/* Q&A Interface */}
        <div className="lg:col-span-2">
          <div className="bg-white border border-gray-200 rounded-lg p-6">
            <h2 className="text-lg font-semibold mb-4">Fazer Perguntas</h2>

            {/* Messages */}
            <div className="h-96 overflow-y-auto mb-4 space-y-4">
              {messages.length === 0 && (
                <div className="text-gray-500 text-center py-8">
                  Envie documents e faça perguntas para começar!

                  <div className="mt-4 text-sm">
                    <p className="font-medium">Experimente perguntar:</p>
                    <ul className="mt-2 space-y-1">
                      <li>"Quais são os principais achados?"</li>
                      <li>"Resuma os pontos-chave"</li>
                      <li>"O que a seção 3 diz sobre...?"</li>
                    </ul>
                  </div>
                </div>
              )}

              {messages.map((message) => (
                <div
                  key={message.id}
                  className={`p-4 rounded-lg ${
                    message.role === 'user'
                      ? 'bg-blue-500 text-white ml-8'
                      : 'bg-gray-100 mr-8'
                  }`}
                >
                  <div className="whitespace-pre-wrap">{message.content}</div>

                  {message.role === 'assistant' && sources.length > 0 && (
                    formatSources(sources)
                  )}
                </div>
              ))}

              {isLoading && (
                <div className="bg-gray-100 p-4 rounded-lg mr-8">
                  <div className="flex items-center space-x-2">
                    <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
                    <span>Buscando documents e gerando resposta...</span>
                  </div>
                </div>
              )}
            </div>

            {/* Input */}
            <form onSubmit={handleSubmit} className="flex gap-2">
              <input
                value={input}
                onChange={handleInputChange}
                placeholder="Faça uma pergunta sobre seus documentos..."
                className="flex-1 p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                disabled={isLoading || documents.length === 0}
              />
              <button
                type="submit"
                disabled={isLoading || !input.trim() || documents.length === 0}
                className="px-6 py-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                Perguntar
              </button>
            </form>

            {documents.length === 0 && (
              <p className="text-sm text-gray-500 mt-2">
                Envie documentos primeiro para habilitar perguntas
              </p>
            )}
          </div>
        </div>
      </div>
    </div>
  )
}
```

<div id="testing-your-qa-system">
  ## Testando seu sistema de Perguntas e Respostas
</div>

<div id="step-4-test-document-processing">
  ### Etapa 4: Testar o processamento de documentos
</div>

1. **Carregar documentos de teste**:
   - Envie um manual em PDF ou um artigo acadêmico
   - Adicione alguns artigos da web via url
   - Envie alguns arquivos de texto com tópicos diferentes

2. **Testar tipos de perguntas**:
   ```
   Factual: "Qual é a definição de X mencionada nos documents?"
   Analytical: "Quais são os prós e contras da abordagem Y?"
   Comparative: "Como o método A se compara ao método B?"
   Summarization: "Resuma as principais conclusões"
   ```

3. **Verificar citações**:
   - Verifique se as citações aparecem nas respostas
   - Confirme se os números das citações correspondem à lista de fontes
   - Garanta que as fontes exibam metadata relevante

<div id="production-considerations">
  ## Considerações de Produção
</div>

<div id="performance-optimization">
  ### Otimização de performance
</div>

```typescript
// Implemente cache para perguntas frequentes
const cacheKey = `qa:${collection}:${hashQuery(question)}`
const cachedResponse = await redis.get(cacheKey)

if (cachedResponse) {
  return JSON.parse(cachedResponse)
}

// Armazene a resposta em cache por 1 hora
await redis.setex(cacheKey, 3600, JSON.stringify(response))
```


<div id="advanced-features">
  ### Recursos avançados
</div>

1. **Perguntas de acompanhamento**:
   ```typescript
   // Rastreie o contexto da conversa
   const conversationHistory = messages.slice(-6) // Últimas 3 interações
   ```

2. **Pontuação de confiança da resposta**:
   ```typescript
   const confidence = calculateConfidence({
     searchScore: searchResults.results[0]?.score || 0,
     resultCount: searchResults.results.length,
     chunkRelevance: avgChunkRelevance
   })
   ```

3. **Suporte multilíngue**:
   ```typescript
   // Detecte o idioma da pergunta e adapte a busca
   const detectedLanguage = await detectLanguage(question)
   const searchResults = await client.search.documents({
     q: question,
     filters: {
       AND: [{ key: 'language', value: detectedLanguage }]
     }
   })
   ```

Esta receita oferece uma base completa para criar sistemas de perguntas e respostas com documentos, com citações precisas e rastreamento de fontes.

---

*Personalize esta receita de acordo com seus tipos específicos de documents e casos de uso.*