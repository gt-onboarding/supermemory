---
title: "Memory API と Router — どちらを使うべき？"
sidebarTitle: "Memory API vs Router"
description: "LLM に長期メモリーを追加する2つの方法。同じエンジンを共有。速度（Router）か制御（Memory API）を選ぶ、または両方を併用。"
---

<Tip>
### <strong>要点</strong>
- <strong>Memory API:</strong> メモリーの取り込み/検索/filters を自分で行い、プロンプトに何を入れるかを正確に決められます。プロダクションアプリやカスタムリトリーバル向けに最大のコントロールを提供します。<br/>
- <strong>Memory Router:</strong> 既存の LLM クライアントはそのままに、Supermemory をエンドポイントとして指定するだけ。関連するメモリーを自動で取得し、プロンプトに付与します。<br />

どちらも同じメモリーエンジンを使用し、共通のキー（`user_id`）を共有します。したがって、API 経由で保存したものは `user_id` が一致する限り Router でも利用でき、その逆も同様です。
</Tip>

まず Router の仕組みを説明します。API は比較的わかりやすいためです。

![](./images/infinite-context.png)

LLM にリクエストを送ると、Supermemory がプロキシとして動作します。Router はメッセージから不要なコンテキストを自動的に取り除き、ユーザーの保存済みメモリから追加の関連コンテキストを検索してプロンプトに付与し、LLM に送信します。 

また、新しいメモリーの書き込みは非同期で行われるため、処理を妨げることなくコンテキストは拡張され続けます。Router はチャットアプリケーションにおける会話メモリー向けに特化しており、会話が非常に長くなるときにその有用性が発揮されます。

開発者にとってのメリットは次のとおりです:

- コードのリファクタリング不要 — Supermemory が提供するベース URL に差し替えるだけ。詳細はクイックスタートを参照。
- モデルのウィンドウを超える長スレッドのリトリーバルにより、チャットボットの性能が向上。
- 自動チャンク分割とコンテキスト管理によりコストを削減。

一方 API は、アプリから呼び出せるフル機能の API で、Documents の取り込み、メモリー作成、検索、Rerank などをきめ細かく制御できます。Router はこの API の上に構築されています。

技術的には、API の上に独自の Memory Router を構築することも可能ですが、ワンライン統合、使いやすさ、最小のレイテンシー、賢いトークン予算管理といった利点は同等ではありません。

重ねて、どちらも同じメモリーエンジンを内部で使用しているため、保存済みメモリは両プロダクト間で共通に利用できます。

特定のユースケースでどちらを使うかを決めるための30秒フローはこちらです:

- <strong> すでに動作する LLM チャットがあり、記憶させたいだけ？ </strong> Router から始めましょう。


- <strong> 新規アプリの構築中、または厳密なテナンシー、filters、ランキング、カスタムプロンプトが必要？ </strong> Memory API を使いましょう。


- <strong> 両方必要？ </strong> 取り込みは API、チャットは Router。user_id を一貫させましょう。


- <strong> まだ迷う？ </strong> まずは Router でパイロットし、より細かいコントロールが必要になった部分を API に段階的に移行。

では、クイックスタートに進み、5分で API/Router をあなたのアプリに統合しましょう。

<div id="faqs">
  ## よくある質問
</div>

<AccordionGroup>
  <Accordion title="Router は裏で単に Memory API を呼び出しているだけですか？">
    概念的にはそのとおりです。Router は同じ Supermemory エンジンの処理（retrieve、re-rank、budget、cite）をオーケストレーションし、モデル呼び出しに組み合わせて実行します。
  </Accordion>
  <Accordion title="Router は新しいメモリーを自動的に保存しますか？">
    可能です。create-memory ステップは非同期のため、ユーザーへの応答は遅延しません。
  </Accordion>
  <Accordion title="Router と API をまたいでユーザーのメモリーを識別するのは何ですか？">
    <code>user_id</code> です。Router と API の呼び出しで一貫させることで、同じメモリープールを共有できます。
  </Accordion>
</AccordionGroup>