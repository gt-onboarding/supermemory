---
title: "処理ステータスを追跡する"
description: "documents の処理ステータスをリアルタイムに監視する"
icon: "activity"
---

より良いユーザー体験を提供し、エッジケースに適切に対処するために、処理パイプライン全体で documents を追跡します。

<div id="processing-pipeline">
  ## 処理パイプライン
</div>

![documents を保存メモリに変換するプロセス](/images/pipeline.png)

各ステージにはそれぞれの役割があります:

- **Queued**: Document は処理キューで待機中
- **Extracting**: コンテンツを抽出中（画像は OCR、動画は文字起こし）
- **Chunking**: コンテンツを検索に最適な単位へ分割
- **Embedding**: 各チャンクをベクトル表現に変換
- **Indexing**: ベクトルを検索インデックスに追加
- **Done**: Document は処理完了・検索可能

<Note>
処理時間はコンテンツの種類によって異なります。プレーンテキストは数秒で完了しますが、10分の動画は 2～3 分かかる場合があります。
</Note>

<div id="processing-documents">
  ## documents の処理
</div>

アカウント内で現在処理中のすべての documents を監視します。

`GET /v3/documents/processing`

<CodeGroup>

```typescript
// 直接の API 呼び出し（SDK ではない）
const response = await fetch('https://api.supermemory.ai/v3/documents/processing', {
  headers: {
    'Authorization': `Bearer ${SUPERMEMORY_API_KEY}`
  }
});

const processing = await response.json();
console.log(`${processing.documents.length} documents processing`);
```

```python
# 直接の API 呼び出し（SDK ではない）
import requests

response = requests.get(
    'https://api.supermemory.ai/v3/documents/processing',
    headers={'Authorization': f'Bearer {SUPERMEMORY_API_KEY}'}
)

processing = response.json()
print(f"{len(processing['documents'])} documents processing")
```

```bash
curl -X GET "https://api.supermemory.ai/v3/documents/processing" \
  -H "Authorization: Bearer $SUPERMEMORY_API_KEY"
```

</CodeGroup>

<div id="response-format">
  ### レスポンス形式
</div>

```json
{
  "documents": [
    {
      "id": "doc_abc123",
      "status": "extracting",
      "created_at": "2024-01-15T10:30:00Z",
      "updated_at": "2024-01-15T10:30:15Z",
      "container_tags": ["research"],
      "metadata": {
        "source": "upload",
        "filename": "report.pdf"
      }
    },
    {
      "id": "doc_def456",
      "status": "chunking",
      "created_at": "2024-01-15T10:29:00Z",
      "updated_at": "2024-01-15T10:30:00Z",
      "container_tags": ["articles"],
      "metadata": {
        "source": "url",
        "url": "https://example.com/article"
      }
    }
  ],
  "total": 2
}
```


<div id="individual-documents">
  ## 個別のdocuments
</div>

特定のドキュメントの処理statusを追跡します。

`GET /v3/documents/{id}`

<CodeGroup>

```typescript
const memory = await client.memories.get("doc_abc123");

console.log(`Status: ${memory.status}`);

// 完了までポーリング
while (memory.status !== 'done') {
  await new Promise(r => setTimeout(r, 2000));
  memory = await client.memories.get("doc_abc123");
  console.log(`Status: ${memory.status}`);
}
```

```python
memory = client.memories.get("doc_abc123")

print(f"Status: {memory['status']}")

# 完了までポーリング
import time
while memory['status'] != 'done':
    time.sleep(2)
    memory = client.memories.get("doc_abc123")
    print(f"Status: {memory['status']}")
```

```bash
curl -X GET "https://api.supermemory.ai/v3/documents/doc_abc123" \
  -H "Authorization: Bearer $SUPERMEMORY_API_KEY"
```

</CodeGroup>

<div id="response-format">
  ### レスポンス形式
</div>

```json
{
  "id": "doc_abc123",
  "status": "done",
  "content": "オリジナルのコンテンツ...",
  "container_tags": ["research"],
  "metadata": {
    "source": "upload",
    "filename": "report.pdf"
  },
  "created_at": "2024-01-15T10:30:00Z",
  "updated_at": "2024-01-15T10:31:00Z"
}
```


<div id="status-values">
  ## status 値
</div>

| status | 説明 | 目安の所要時間 |
|--------|-------------|------------------|
| `queued` | 処理待ち | < 5秒 |
| `extracting` | ソースから内容を抽出中 | 5〜30秒 |
| `chunking` | 検索しやすい単位にチャンク化（分割処理） | 5〜15秒 |
| `embedding` | ベクトル表現（埋め込み）を生成中 | 10〜30秒 |
| `indexing` | 検索インデックスに追加中（インデキシング） | 5〜10秒 |
| `done` | 処理が完了し検索可能 | - |
| `failed` | 処理に失敗 | - |

<div id="polling-best-practices">
  ## ポーリングのベストプラクティス
</div>

status の更新をポーリングする際は:

```typescript
async function waitForProcessing(documentId: string, maxWaitMs = 300000) {
  const startTime = Date.now();
  const pollInterval = 2000; // 2 秒

  while (Date.now() - startTime < maxWaitMs) {
    const doc = await client.memories.get(documentId);

    if (doc.status === 'done') {
      return doc;
    }

    if (doc.status === 'failed') {
      throw new Error(`ドキュメント ${documentId} の処理に失敗しました`);
    }

    await new Promise(r => setTimeout(r, pollInterval));
  }

  throw new Error(`ドキュメント ${documentId} の待機がタイムアウトしました`);
}
```


<div id="batch-processing">
  ## バッチ処理
</div>

複数のdocumentsを扱う場合は、効率的に追跡しましょう。

```typescript
async function trackBatch(documentIds: string[]) {
  const statuses = new Map();

  // 初回の確認
  for (const id of documentIds) {
    const doc = await client.memories.get(id);
    statuses.set(id, doc.status);
  }

  // すべて完了するまでポーリング
  while ([...statuses.values()].some(s => s !== 'done' && s !== 'failed')) {
    await new Promise(r => setTimeout(r, 5000)); // バッチ用の 5 秒間隔

    for (const id of documentIds) {
      if (statuses.get(id) !== 'done' && statuses.get(id) !== 'failed') {
        const doc = await client.memories.get(id);
        statuses.set(id, doc.status);
      }
    }

    // 進捗をログ出力
    const done = [...statuses.values()].filter(s => s === 'done').length;
    console.log(`進捗: ${done}/${documentIds.length} 件 完了`);
  }

  return statuses;
}
```


<div id="error-handling">
  ## エラー処理
</div>

処理の失敗を穏当かつ丁寧に扱う:

```typescript
async function addWithRetry(content: string, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    const { id } = await client.memories.add({ content });

    try {
      const result = await waitForProcessing(id);
      return result;
    } catch (error) {
      console.error(`試行 ${attempt} に失敗しました:`, error);

      if (attempt === maxRetries) {
        throw error;
      }

      // 指数バックオフ
      await new Promise(r => setTimeout(r, 1000 * Math.pow(2, attempt)));
    }
  }
}
```


<div id="processing-times-by-content-type">
  ## コンテンツタイプ別の処理時間
</div>

documents: ほぼ瞬時に作成（200～500ms）

保存メモリ: Supermemory は、セマンティック解析とコンテキスト理解に基づいてメモリーグラフを構築します。

| コンテンツタイプ | メモリー処理時間 | 備考 |
|--------------|------------------------|-------|
| プレーンテキスト | 5～10秒 | 最速 |
| Markdown | 5～10秒 | プレーンテキストと同等 |
| PDF（10ページ未満） | 15～30秒 | 必要に応じて OCR |
| PDF（100ページ超） | 1～3分 | 内容の複雑さに依存 |
| 画像 | 10～20秒 | OCR 処理 |
| YouTube 動画 | 10分の動画あたり1～2分 | 文字起こしが必要 |
| Web ページ | 10～20秒 | コンテンツ抽出 |
| Google ドキュメント | 10～15秒 | API による抽出 |

<Note>
**プロ向けのコツ**: 特に大きな documents や一括アップロードでは、ユーザーにリアルタイムでフィードバックを提供するために processing status エンドポイントを使用してください。
</Note>