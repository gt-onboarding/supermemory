---
title: "ドキュメントQ&Aシステム"
description: "documentsの内容に基づき、引用と出典を明記して質問に答えるチャットボットを構築する"
---

PDF、テキストファイル、Webページを取り込める高機能なドキュメントQ&Aシステムを構築し、正確な引用と出典付きで質問に回答します。ドキュメントサイト、研究データベース、社内ナレッジベースに最適です。

<div id="what-youll-build">
  ## 作成するもの
</div>

次の機能を備えたドキュメントQ&Aシステム:

- **複数のファイル形式を取り込む**（PDF、DOCX、テキスト、URL）
- **出典を明示して正確に回答する**
- **ページ番号とドキュメントのタイトル付きで出典を提示する**
- **会話の文脈を保持して後続の質問に対応する**
- **トピックごとに複数のドキュメントコレクションをサポートする**

<div id="prerequisites">
  ## 前提条件
</div>

- Node.js 18+ または Python 3.8+
- Supermemory の APIキー
- OpenAI の APIキー
- ファイル操作に関する基本的な知識

<div id="implementation">
  ## 実装
</div>

<div id="step-1-document-processing-system">
  ### ステップ1：ドキュメント処理システム
</div>

<Tabs>
  <Tab title="Next.js">
    ```typescript lib/document-processor.ts
    import { Supermemory } from 'supermemory'

    const client = new Supermemory({
      apiKey: process.env.SUPERMEMORY_API_KEY!
    })

    interface DocumentUpload {
      file: File
      collection: string
      metadata?: Record<string, any>
    }

    export class DocumentProcessor {
      async uploadDocument({ file, collection, metadata = {} }: DocumentUpload) {
        try {
          const formData = new FormData()
          formData.append('file', file)
          formData.append('containerTags', JSON.stringify([collection]))
          formData.append('metadata', JSON.stringify({
            originalName: file.name,
            fileType: file.type,
            uploadedAt: new Date().toISOString(),
            ...metadata
          }))

          const response = await fetch('/api/upload-document', {
            method: 'POST',
            body: formData
          })

          if (!response.ok) {
            throw new Error(`アップロードに失敗しました: ${response.statusText}`)
          }

          return await response.json()
        } catch (error) {
          console.error('ドキュメントアップロードエラー:', error)
          throw error
        }
      }

      async uploadURL({ url, collection, metadata = {} }: { url: string, collection: string, metadata?: Record<string, any> }) {
        try {
          const result = await client.memories.add({
            content: url,
            containerTag: collection,
            metadata: {
              type: 'url',
              originalUrl: url,
              uploadedAt: new Date().toISOString(),
              ...metadata
            }
          })

          return result
        } catch (error) {
          console.error('URLアップロードエラー:', error)
          throw error
        }
      }

      async getDocumentStatus(documentId: string) {
        try {
          const memory = await client.memories.get(documentId)
          return {
            id: memory.id,
            status: memory.status,
            title: memory.title,
            progress: memory.metadata?.progress || 0
          }
        } catch (error) {
          console.error('ステータス確認エラー:', error)
          throw error
        }
      }

      async listDocuments(collection: string) {
        try {
          const memories = await client.memories.list({
            containerTags: [collection],
            limit: 50,
            sort: 'updatedAt',
            order: 'desc'
          })

          return memories.memories.map(memory => ({
            id: memory.id,
            title: memory.title || memory.metadata?.originalName || '無題',
            type: memory.metadata?.fileType || memory.metadata?.type || '不明',
            uploadedAt: memory.metadata?.uploadedAt,
            status: memory.status,
            url: memory.metadata?.originalUrl
          }))
        } catch (error) {
          console.error('ドキュメント一覧エラー:', error)
          throw error
        }
      }
    }
    ```

    ```typescript app/api/upload-document/route.ts
    import { NextRequest, NextResponse } from 'next/server'
    import { Supermemory } from 'supermemory'

    const client = new Supermemory({
      apiKey: process.env.SUPERMEMORY_API_KEY!
    })

    export async function POST(request: NextRequest) {
      try {
        const formData = await request.formData()
        const file = formData.get('file') as File
        const containerTags = JSON.parse(formData.get('containerTags') as string)
        const metadata = JSON.parse(formData.get('metadata') as string || '{}')

        if (!file) {
          return NextResponse.json({ error: 'ファイルが提供されていません' }, { status: 400 })
        }

        // SupermemoryのためにFileをBufferに変換
        const bytes = await file.arrayBuffer()
        const buffer = Buffer.from(bytes)

        const result = await client.memories.uploadFile({
          file: buffer,
          filename: file.name,
          containerTags,
          metadata
        })

        return NextResponse.json({
          success: true,
          documentId: result.id,
          message: 'ドキュメントが正常にアップロードされました'
        })

      } catch (error) {
        console.error('アップロードエラー:', error)
        return NextResponse.json(
          { error: 'アップロードに失敗しました', details: error.message },
          { status: 500 }
        )
      }
    }
    ```
  </Tab>

  <Tab title="Python">
    ```python document_processor.py
    from supermemory import Supermemory
    import os
    from typing import Dict, List, Any, Optional
    import requests
    from datetime import datetime

    class DocumentProcessor:
        def __init__(self):
            self.client = Supermemory(api_key=os.getenv("SUPERMEMORY_API_KEY"))

        def upload_file(self, file_path: str, collection: str, metadata: Dict[str, Any] = None) -> Dict:
            """ローカルファイルをSupermemoryにアップロード"""
            if metadata is None:
                metadata = {}

            try:
                with open(file_path, 'rb') as file:
                    result = self.client.memories.upload_file(
                        file=file,
                        container_tags=[collection],
                        metadata={
                            'originalName': os.path.basename(file_path),
                            'fileType': os.path.splitext(file_path)[1],
                            'uploadedAt': datetime.now().isoformat(),
                            **metadata
                        }
                    )
                return result
            except Exception as e:
                print(f"ファイルアップロードエラー: {e}")
                raise

        def upload_url(self, url: str, collection: str, metadata: Dict[str, Any] = None) -> Dict:
            """URLコンテンツをSupermemoryにアップロード"""
            if metadata is None:
                metadata = {}

            try:
                result = self.client.memories.add(
                    content=url,
                    container_tag=collection,
                    metadata={
                        'type': 'url',
                        'originalUrl': url,
                        'uploadedAt': datetime.now().isoformat(),
                        **metadata
                    }
                )
                return result
            except Exception as e:
                print(f"URLアップロードエラー: {e}")
                raise

        def get_document_status(self, document_id: str) -> Dict:
            """ドキュメント処理ステータスを確認"""
            try:
                memory = self.client.memories.get(document_id)
                return {
                    'id': memory.id,
                    'status': memory.status,
                    'title': memory.title,
                    'progress': memory.metadata.get('progress', 0) if memory.metadata else 0
                }
            except Exception as e:
                print(f"ステータス確認エラー: {e}")
                raise

        def list_documents(self, collection: str) -> List[Dict]:
            """コレクション内のすべてのドキュメントを一覧表示"""
            try:
                memories = self.client.memories.list(
                    container_tags=[collection],
                    limit=50,
                    sort='updatedAt',
                    order='desc'
                )

                return [
                    {
                        'id': memory.id,
                        'title': (memory.title or
                                memory.metadata.get('originalName') or
                                'タイトルなし' if memory.metadata else 'タイトルなし'),
                        'type': (memory.metadata.get('fileType') or
                               memory.metadata.get('type') or
                               '不明' if memory.metadata else '不明'),
                        'uploadedAt': memory.metadata.get('uploadedAt') if memory.metadata else None,
                        'status': memory.status,
                        'url': memory.metadata.get('originalUrl') if memory.metadata else None
                    }
                    for memory in memories.memories
                ]
            except Exception as e:
                print(f"ドキュメント一覧エラー: {e}")
                raise
    ```
  </Tab>
</Tabs>

<div id="step-2-qa-api-with-citations">
  ### ステップ 2: 参照付き Q&A API
</div>

<Tabs>
  <Tab title="Next.js の API ルート">
    ```typescript app/api/qa/route.ts
    import { streamText } from 'ai'
    import { createOpenAI } from '@ai-sdk/openai'
    import { Supermemory } from 'supermemory'

    const openai = createOpenAI({
      apiKey: process.env.OPENAI_API_KEY!
    })

    const client = new Supermemory({
      apiKey: process.env.SUPERMEMORY_API_KEY!
    })

    export async function POST(request: Request) {
      const { question, collection, conversationHistory = [] } = await request.json()

      try {
        // 関連するdocumentsを検索
        const searchResults = await client.search.documents({
          q: question,
          containerTags: [collection],
          limit: 8,
          rerank: true,
          includeFullDocs: false,
          includeSummary: true,
          onlyMatchingChunks: false,
          documentThreshold: 0.6,
          chunkThreshold: 0.7
        })

        if (searchResults.results.length === 0) {
          return Response.json({
            answer: "アップロードされたdocuments内に、あなたの質問に答えるための関連情報を見つけることができませんでした。",
            sources: [],
            confidence: 0
          })
        }

        // 検索結果からコンテキストを準備
        const context = searchResults.results.map((result, index) => {
          const chunks = result.chunks
            .filter(chunk => chunk.isRelevant)
            .slice(0, 3)
            .map(chunk => chunk.content)
            .join('\n\n')

          return `[Document ${index + 1}: "${result.title}"]\n${chunks}`
        }).join('\n\n---\n\n')

        // 引用のためのソースを準備
        const sources = searchResults.results.map((result, index) => ({
          id: result.documentId,
          title: result.title,
          type: result.type,
          relevantChunks: result.chunks.filter(chunk => chunk.isRelevant).length,
          score: result.score,
          citationNumber: index + 1
        }))

        const messages = [
          ...conversationHistory,
          {
            role: 'user' as const,
            content: question
          }
        ]

        const result = await streamText({
          model: openai('gpt-5'),
          messages,
          system: `あなたは親切なdocument Q&Aアシスタントです。提供されたdocumentコンテキストのみに基づいて質問に答えてください。

    DOCUMENTSからのコンテキスト:
    ${context}

    指示:
    1. 提供されたdocumentsの情報のみを使用して質問に答えてください
    2. [Document X] 形式を使用して、回答に具体的な引用を含めてください
    3. documentsに十分な情報が含まれていない場合は、明確にそう述べてください
    4. 正確に、可能な限り直接引用してください
    5. 複数のdocumentsがある点をサポートしている場合は、関連するすべてを引用してください
    6. 親切で専門的な口調を保ってください

    引用形式:
    - ソースを引用するには [Document 1]、[Document 2] などを使用してください
    - 関連情報の後に引用を配置してください
    - 例: "プロセスには3つのステップが含まれます [Document 1]。ただし、一部の専門家は4ステップのアプローチを推奨しています [Document 3]。"

    提供されたdocumentsから質問に答えることができない場合は、次のように回答してください: "提供されたdocuments内に、この質問に正確に答えるための十分な情報がありません。"`,
          temperature: 0.1,
          maxTokens: 1000
        })

        return result.toAIStreamResponse({
          data: {
            sources,
            searchResultsCount: searchResults.results.length,
            totalResults: searchResults.total
          }
        })

      } catch (error) {
        console.error('Q&Aエラー:', error)
        return Response.json(
          { error: '質問の処理に失敗しました', details: error.message },
          { status: 500 }
        )
      }
    }
    ```
  </Tab>

  <Tab title="Python FastAPI">
    ```python qa_api.py
    from fastapi import FastAPI, HTTPException
    from fastapi.responses import StreamingResponse
    from pydantic import BaseModel
    from typing import List, Dict, Any, Optional
    import openai
    from supermemory import Supermemory
    import json
    import os

    app = FastAPI()

    openai_client = openai.AsyncOpenAI(api_key=os.getenv("OPENAI_API_KEY"))
    supermemory_client = Supermemory(api_key=os.getenv("SUPERMEMORY_API_KEY"))

    class QARequest(BaseModel):
        question: str
        collection: str
        conversationHistory: List[Dict[str, str]] = []

    class QAResponse(BaseModel):
        answer: str
        sources: List[Dict[str, Any]]
        confidence: float
        searchResultsCount: int

    @app.post("/qa")
    async def answer_question(request: QARequest):
        try:
            # 関連するdocumentsを検索
            search_results = supermemory_client.search.documents(
                q=request.question,
                container_tags=[request.collection],
                limit=8,
                rerank=True,
                include_full_docs=False,
                include_summary=True,
                only_matching_chunks=False,
                document_threshold=0.6,
                chunk_threshold=0.7
            )

            if not search_results.results:
                return QAResponse(
                    answer="アップロードされたdocuments内に、ご質問にお答えできる関連情報が見つかりませんでした。",
                    sources=[],
                    confidence=0,
                    searchResultsCount=0
                )

            # 検索結果からコンテキストを準備
            context_parts = []
            sources = []

            for index, result in enumerate(search_results.results):
                relevant_chunks = [
                    chunk.content for chunk in result.chunks
                    if chunk.is_relevant
                ][:3]

                chunk_text = '\n\n'.join(relevant_chunks)
                context_parts.append(f'[Document {index + 1}: "{result.title}"]\n{chunk_text}')

                sources.append({
                    'id': result.document_id,
                    'title': result.title,
                    'type': result.type,
                    'relevantChunks': len([c for c in result.chunks if c.is_relevant]),
                    'score': result.score,
                    'citationNumber': index + 1
                })

            context = '\n\n---\n\n'.join(context_parts)

            # メッセージを準備
            messages = [
                {
                    "role": "system",
                    "content": f"""あなたは親切なdocument Q&Aアシスタントです。提供されたdocumentコンテキストのみに基づいて質問にお答えください。

    DOCUMENTS からのコンテキスト:
    {context}

    指示:
    1. 提供されたdocumentsの情報のみを使用して質問にお答えください
    2. [Document X] 形式を使用して、回答に具体的な引用を含めてください
    3. documentsに十分な情報が含まれていない場合は、明確にその旨をお伝えください
    4. 正確性を保ち、可能な限り直接引用してください
    5. 複数のdocumentsが同じ点をサポートしている場合は、関連するすべてを引用してください
    6. 親切で専門的な口調を維持してください

    引用形式:
    - ソースを引用するには [Document 1]、[Document 2] などを使用してください
    - 関連情報の後に引用を配置してください
    - 例: "プロセスには3つのステップが含まれます [Document 1]。ただし、一部の専門家は4ステップのアプローチを推奨しています [Document 3]。"

    提供されたdocumentsから質問にお答えできない場合は、次のように回答してください: "提供されたdocuments内に、この質問に正確にお答えするための十分な情報がありません。" """
                }
            ]

            # 会話履歴を追加
            messages.extend(request.conversationHistory)
            messages.append({"role": "user", "content": request.question})

            # AI応答を取得
            response = await openai_client.chat.completions.create(
                model="gpt-5",
                messages=messages,
                temperature=0.1,
                max_tokens=1000
            )

            answer = response.choices[0].message.content

            return QAResponse(
                answer=answer,
                sources=sources,
                confidence=min(search_results.results[0].score if search_results.results else 0, 1.0),
                searchResultsCount=len(search_results.results)
            )

        except Exception as e:
            raise HTTPException(status_code=500, detail=f"質問の処理に失敗しました: {str(e)}")

    if __name__ == "__main__":
        import uvicorn
        uvicorn.run(app, host="0.0.0.0", port=8000)
    ```
  </Tab>
</Tabs>

<div id="step-3-frontend-interface">
  ### ステップ3：フロントエンド インターフェース
</div>

```tsx app/qa/page.tsx
'use client'

import { useState, useRef } from 'react'
import { useChat } from 'ai/react'
import { DocumentProcessor } from '@/lib/document-processor'

interface Document {
  id: string
  title: string
  type: string
  status: string
  uploadedAt: string
}

interface Source {
  id: string
  title: string
  citationNumber: number
  score: number
  relevantChunks: number
}

export default function DocumentQA() {
  const [collection, setCollection] = useState('default-docs')
  const [documents, setDocuments] = useState<Document[]>([])
  const [sources, setSources] = useState<Source[]>([])
  const [isUploading, setIsUploading] = useState(false)
  const [uploadProgress, setUploadProgress] = useState<Record<string, number>>({})
  const fileInputRef = useRef<HTMLInputElement>(null)

  const processor = new DocumentProcessor()

  const { messages, input, handleInputChange, handleSubmit, isLoading } = useChat({
    api: '/api/qa',
    body: {
      collection
    },
    onFinish: (message, { data }) => {
      if (data?.sources) {
        setSources(data.sources)
      }
    }
  })

  const handleFileUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const files = event.target.files
    if (!files || files.length === 0) return

    setIsUploading(true)
    const newProgress: Record<string, number> = {}

    try {
      for (const file of Array.from(files)) {
        newProgress[file.name] = 0
        setUploadProgress({ ...newProgress })

        await processor.uploadDocument({
          file,
          collection,
          metadata: {
            uploadedBy: 'user',
            category: 'qa-document'
          }
        })

        newProgress[file.name] = 100
        setUploadProgress({ ...newProgress })
      }

      // Refresh document list
      await loadDocuments()

      // Clear file input
      if (fileInputRef.current) {
        fileInputRef.current.value = ''
      }

    } catch (error) {
      console.error('Upload failed:', error)
      alert('Upload failed: ' + error.message)
    } finally {
      setIsUploading(false)
      setUploadProgress({})
    }
  }

  const loadDocuments = async () => {
    try {
      const docs = await processor.listDocuments(collection)
      setDocuments(docs)
    } catch (error) {
      console.error('Failed to load documents:', error)
    }
  }

  const formatSources = (sources: Source[]) => {
    if (!sources || sources.length === 0) return null

    return (
      <div className="mt-4 p-4 bg-gray-50 border border-gray-200 rounded-lg">
        <h3 className="text-sm font-semibold text-gray-700 mb-2">参照元:</h3>
        <div className="space-y-2">
          {sources.map((source) => (
            <div key={source.id} className="flex items-center space-x-2 text-sm">
              <span className="bg-blue-100 text-blue-800 px-2 py-1 rounded text-xs font-mono">
                Document {source.citationNumber}
              </span>
              <span className="text-gray-700">{source.title}</span>
              <span className="text-gray-500">
                ({source.relevantChunks} 関連chunks、{(source.score * 100).toFixed(1)}% 一致)
              </span>
            </div>
          ))}
        </div>
      </div>
    )
  }

  return (
    <div className="max-w-6xl mx-auto p-6">
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* Document Management Panel */}
        <div className="lg:col-span-1">
          <div className="bg-white border border-gray-200 rounded-lg p-6">
            <h2 className="text-lg font-semibold mb-4">ドキュメントコレクション</h2>

            {/* Collection Selector */}
            <div className="mb-4">
              <label className="block text-sm font-medium text-gray-700 mb-2">
                コレクション名
              </label>
              <input
                type="text"
                value={collection}
                onChange={(e) => setCollection(e.target.value)}
                className="w-full p-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                placeholder="例: company-docs"
              />
            </div>

            {/* File Upload */}
            <div className="mb-4">
              <input
                ref={fileInputRef}
                type="file"
                multiple
                accept=".pdf,.docx,.txt,.md"
                onChange={handleFileUpload}
                className="hidden"
              />
              <button
                onClick={() => fileInputRef.current?.click()}
                disabled={isUploading}
                className="w-full p-3 border-2 border-dashed border-gray-300 rounded-lg hover:border-blue-400 focus:ring-2 focus:ring-blue-500 disabled:opacity-50"
              >
                {isUploading ? 'アップロード中...' : 'ドキュメントをアップロード'}
              </button>
            </div>

            {/* Upload Progress */}
            {Object.keys(uploadProgress).length > 0 && (
              <div className="mb-4 space-y-2">
                {Object.entries(uploadProgress).map(([filename, progress]) => (
                  <div key={filename} className="text-sm">
                    <div className="flex justify-between">
                      <span className="truncate">{filename}</span>
                      <span>{progress}%</span>
                    </div>
                    <div className="w-full bg-gray-200 rounded-full h-2">
                      <div
                        className="bg-blue-600 h-2 rounded-full transition-all duration-300"
                        style={{ width: `${progress}%` }}
                      />
                    </div>
                  </div>
                ))}
              </div>
            )}

            {/* Document List */}
            <div className="max-h-64 overflow-y-auto">
              {documents.map((doc) => (
                <div key={doc.id} className="mb-2 p-2 bg-gray-50 rounded text-sm">
                  <div className="font-medium truncate">{doc.title}</div>
                  <div className="text-gray-500 text-xs">
                    {doc.type} • {doc.status}
                  </div>
                </div>
              ))}
            </div>

            <button
              onClick={loadDocuments}
              className="w-full mt-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
            >
              ドキュメントを更新
            </button>
          </div>
        </div>

        {/* Q&A Interface */}
        <div className="lg:col-span-2">
          <div className="bg-white border border-gray-200 rounded-lg p-6">
            <h2 className="text-lg font-semibold mb-4">質問する</h2>

            {/* Messages */}
            <div className="h-96 overflow-y-auto mb-4 space-y-4">
              {messages.length === 0 && (
                <div className="text-gray-500 text-center py-8">
                  ドキュメントをアップロードして質問を開始してください！

                  <div className="mt-4 text-sm">
                    <p className="font-medium">試してみてください:</p>
                    <ul className="mt-2 space-y-1">
                      <li>"主な発見は何ですか？"</li>
                      <li>"重要なポイントを要約してください"</li>
                      <li>"セクション3では...について何と言っていますか？"</li>
                    </ul>
                  </div>
                </div>
              )}

              {messages.map((message) => (
                <div
                  key={message.id}
                  className={`p-4 rounded-lg ${
                    message.role === 'user'
                      ? 'bg-blue-500 text-white ml-8'
                      : 'bg-gray-100 mr-8'
                  }`}
                >
                  <div className="whitespace-pre-wrap">{message.content}</div>

                  {message.role === 'assistant' && sources.length > 0 && (
                    formatSources(sources)
                  )}
                </div>
              ))}

              {isLoading && (
                <div className="bg-gray-100 p-4 rounded-lg mr-8">
                  <div className="flex items-center space-x-2">
                    <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
                    <span>ドキュメントを検索して回答を生成中...</span>
                  </div>
                </div>
              )}
            </div>

            {/* Input */}
            <form onSubmit={handleSubmit} className="flex gap-2">
              <input
                value={input}
                onChange={handleInputChange}
                placeholder="あなたのdocumentsについて質問してください..."
                className="flex-1 p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                disabled={isLoading || documents.length === 0}
              />
              <button
                type="submit"
                disabled={isLoading || !input.trim() || documents.length === 0}
                className="px-6 py-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                質問する
              </button>
            </form>

            {documents.length === 0 && (
              <p className="text-sm text-gray-500 mt-2">
                質問を有効にするには、まずdocumentsをアップロードしてください
              </p>
            )}
          </div>
        </div>
      </div>
    </div>
  )
}
```

<div id="testing-your-qa-system">
  ## Q&Aシステムのテスト
</div>

<div id="step-4-test-document-processing">
  ### ステップ 4: ドキュメント処理のテスト
</div>

1. **テスト用 documents をアップロード**:
   - PDFのマニュアルまたは研究論文をアップロード
   - url 経由でいくつかのウェブ記事を追加
   - トピックの異なるテキストファイルをいくつかアップロード

2. **質問タイプのテスト**:
   ```
   事実確認: "documents に記載されている X の定義は何ですか？"
   分析: "アプローチ Y の長所と短所は何ですか？"
   比較: "手法Aは手法Bとどう違いますか？"
   要約: "主要な知見を要約してください"
   ```

3. **出典の確認**:
   - 応答に出典が表示されることを確認
   - 引用番号がソース一覧と一致していることを確認
   - ソースに関連するメタデータが表示されていることを確認

<div id="production-considerations">
  ## 運用環境での考慮事項
</div>

<div id="performance-optimization">
  ### パフォーマンスの最適化
</div>

```typescript
// よくある質問向けのキャッシュを実装する
const cacheKey = `qa:${collection}:${hashQuery(question)}`
const cachedResponse = await redis.get(cacheKey)

if (cachedResponse) {
  return JSON.parse(cachedResponse)
}

// レスポンスを1時間キャッシュする
await redis.setex(cacheKey, 3600, JSON.stringify(response))
```


<div id="advanced-features">
  ### 高度な機能
</div>

1. **フォローアップ質問**:
   ```typescript
   // 会話の文脈を追跡
   const conversationHistory = messages.slice(-6) // 直近の3往復
   ```

2. **回答の信頼度スコアリング**:
   ```typescript
   const confidence = calculateConfidence({
     searchScore: searchResults.results[0]?.score || 0,
     resultCount: searchResults.results.length,
     chunkRelevance: avgChunkRelevance
   })
   ```

3. **多言語対応**:
   ```typescript
   // documents の言語を検出し、検索を適応
   const detectedLanguage = await detectLanguage(question)
   const searchResults = await client.search.documents({
     q: question,
     filters: {
       AND: [{ key: 'language', value: detectedLanguage }]
     }
   })
   ```

このレシピは、正確な出典の明示とソース追跡を備えた document Q&A システムを構築するための堅牢な基盤を提供します。

---

*特定の document タイプやユースケースに合わせて、このレシピをカスタマイズしてください。*