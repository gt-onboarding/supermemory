---
title: "カスタマーサポートボット"
description: "顧客の履歴を保持し、個別化された支援を提供するインテリジェントなサポートシステムを構築する"
---

すべてのやり取りを記憶し、会話をまたいで課題を追跡し、顧客の履歴や嗜好に基づいて個別化されたサポートを提供するカスタマーサポートシステムを構築します。

<div id="what-youll-build">
  ## 作るもの
</div>

以下の機能を備えたカスタマーサポートボット:

- すべての会話やチャネルにまたがる**顧客履歴を記憶**
- **進行中の課題を追跡**し、自動でフォローアップ
- 顧客のティアや嗜好に基づいて**パーソナライズされた応答を提供**
- 複雑な問題を**十分なコンテキストとともに人間の担当者へエスカレーション**
- 解決結果から**学習して今後の応答を改善**

<div id="prerequisites">
  ## 前提条件
</div>

- Node.js 18+ または Python 3.8+
- Supermemory の APIキー
- OpenAI の APIキー
- 顧客データベースまたは CRM との連携
- カスタマーサポートのワークフローに関する基本的な理解

<div id="implementation">
  ## 実装
</div>

<div id="step-1-customer-context-management">
  ### ステップ 1: 顧客コンテキスト管理
</div>

<Tabs>
  <Tab title="Next.js">
    ```typescript lib/customer-context.ts
    import { Supermemory } from 'supermemory'

    const client = new Supermemory({
      apiKey: process.env.SUPERMEMORY_API_KEY!
    })

    interface Customer {
      id: string
      email: string
      name: string
      tier: 'free' | 'pro' | 'enterprise'
      joinDate: string
      preferences?: Record<string, any>
    }

    interface SupportTicket {
      id: string
      customerId: string
      subject: string
      status: 'open' | 'pending' | 'resolved' | 'closed'
      priority: 'low' | 'medium' | 'high' | 'urgent'
      category: string
      createdAt: string
      updatedAt: string
      assignedAgent?: string
    }

    export class CustomerContextManager {
      private getContainerTag(customerId: string): string {
        return `customer_${customerId}`
      }

      async addInteraction(customerId: string, interaction: {
        type: 'chat' | 'email' | 'phone' | 'ticket'
        content: string
        channel: string
        outcome?: 'resolved' | 'escalated' | 'pending'
        agentId?: string
        metadata?: Record<string, any>
      }) {
        try {
          const result = await client.memories.add({
            content: `${interaction.type.toUpperCase()}: ${interaction.content}`,
            containerTag: this.getContainerTag(customerId),
            metadata: {
              type: 'customer_interaction',
              interactionType: interaction.type,
              channel: interaction.channel,
              outcome: interaction.outcome,
              agentId: interaction.agentId,
              timestamp: new Date().toISOString(),
              ...interaction.metadata
            }
          })

          return result
        } catch (error) {
          console.error('顧客インタラクションの追加に失敗しました:', error)
          throw error
        }
      }

      async getCustomerHistory(customerId: string, limit: number = 10) {
        try {
          const memories = await client.memories.list({
            containerTags: [this.getContainerTag(customerId)],
            limit,
            sort: 'updatedAt',
            order: 'desc'
          })

          return memories.memories.map(memory => ({
            id: memory.id,
            content: memory.content,
            type: memory.metadata?.interactionType || 'unknown',
            channel: memory.metadata?.channel,
            outcome: memory.metadata?.outcome,
            timestamp: memory.metadata?.timestamp || memory.createdAt,
            agentId: memory.metadata?.agentId
          }))
        } catch (error) {
          console.error('顧客履歴の取得に失敗しました:', error)
          throw error
        }
      }

      async searchCustomerContext(customerId: string, query: string) {
        try {
          const results = await client.search.memories({
            q: query,
            containerTag: this.getContainerTag(customerId),
            threshold: 0.6,
            limit: 5,
            rerank: true
          })

          return results.results.map(result => ({
            content: result.memory,
            similarity: result.similarity,
            metadata: result.metadata
          }))
        } catch (error) {
          console.error('顧客コンテキストの検索に失敗しました:', error)
          throw error
        }
      }

      async trackIssue(customerId: string, issue: {
        subject: string
        description: string
        category: string
        priority: 'low' | 'medium' | 'high' | 'urgent'
        status: 'open' | 'pending' | 'resolved'
      }) {
        try {
          const issueContent = `問題: ${issue.subject}\n\n説明: ${issue.description}\nカテゴリ: ${issue.category}\n優先度: ${issue.priority}\nステータス: ${issue.status}`

          const result = await client.memories.add({
            content: issueContent,
            containerTag: this.getContainerTag(customerId),
            metadata: {
              type: 'support_issue',
              subject: issue.subject,
              category: issue.category,
              priority: issue.priority,
              status: issue.status,
              createdAt: new Date().toISOString()
            }
          })

          return result
        } catch (error) {
          console.error('問題の追跡に失敗しました:', error)
          throw error
        }
      }

      async updateIssueStatus(issueId: string, status: 'open' | 'pending' | 'resolved' | 'closed', resolution?: string) {
        try {
          // 注意: 実際の実装では、メモリーを更新します
          // 今回は、ステータス更新を追加します
          const memory = await client.memories.get(issueId)
          const customerId = memory.containerTag.replace('customer_', '')

          const updateContent = `問題更新: ${memory.metadata?.subject}\nステータス変更先: ${status}${resolution ? `\n解決策: ${resolution}` : ''}`

          return await this.addInteraction(customerId, {
            type: 'ticket',
            content: updateContent,
            channel: 'internal',
            outcome: status === 'resolved' ? 'resolved' : 'pending',
            metadata: {
              originalIssueId: issueId,
              statusUpdate: true
            }
          })
        } catch (error) {
          console.error('問題ステータスの更新に失敗しました:', error)
          throw error
        }
      }
    }
    ```
  </Tab>

  <Tab title="Python">
    ```python customer_context.py
    from supermemory import Supermemory
    import os
    from typing import Dict, List, Any, Optional
    from datetime import datetime
    from enum import Enum

    class InteractionType(Enum):
        CHAT = "chat"
        EMAIL = "email"
        PHONE = "phone"
        TICKET = "ticket"

    class Priority(Enum):
        LOW = "low"
        MEDIUM = "medium"
        HIGH = "high"
        URGENT = "urgent"

    class Status(Enum):
        OPEN = "open"
        PENDING = "pending"
        RESOLVED = "resolved"
        CLOSED = "closed"

    class CustomerContextManager:
        def __init__(self):
            self.client = Supermemory(api_key=os.getenv("SUPERMEMORY_API_KEY"))

        def _get_container_tag(self, customer_id: str) -> str:
            return f"customer_{customer_id}"

        def add_interaction(self, customer_id: str, interaction: Dict[str, Any]) -> Dict:
            """顧客とのやり取りをメモリーに追加"""
            try:
                content = f"{interaction['type'].upper()}: {interaction['content']}"

                result = self.client.memories.add(
                    content=content,
                    container_tag=self._get_container_tag(customer_id),
                    metadata={
                        'type': 'customer_interaction',
                        'interactionType': interaction['type'],
                        'channel': interaction['channel'],
                        'outcome': interaction.get('outcome'),
                        'agentId': interaction.get('agentId'),
                        'timestamp': datetime.now().isoformat(),
                        **interaction.get('metadata', {})
                    }
                )
                return result
            except Exception as e:
                print(f"顧客とのやり取りの追加に失敗しました: {e}")
                raise

        def get_customer_history(self, customer_id: str, limit: int = 10) -> List[Dict]:
            """顧客とのやり取り履歴を取得"""
            try:
                memories = self.client.memories.list(
                    container_tags=[self._get_container_tag(customer_id)],
                    limit=limit,
                    sort='updatedAt',
                    order='desc'
                )

                return [
                    {
                        'id': memory.id,
                        'content': memory.content,
                        'type': memory.metadata.get('interactionType', 'unknown') if memory.metadata else 'unknown',
                        'channel': memory.metadata.get('channel') if memory.metadata else None,
                        'outcome': memory.metadata.get('outcome') if memory.metadata else None,
                        'timestamp': memory.metadata.get('timestamp', memory.created_at) if memory.metadata else memory.created_at,
                        'agentId': memory.metadata.get('agentId') if memory.metadata else None
                    }
                    for memory in memories.memories
                ]
            except Exception as e:
                print(f"顧客履歴の取得に失敗しました: {e}")
                raise

        def search_customer_context(self, customer_id: str, query: str) -> List[Dict]:
            """顧客とのやり取り履歴を検索"""
            try:
                results = self.client.search.memories(
                    q=query,
                    container_tag=self._get_container_tag(customer_id),
                    threshold=0.6,
                    limit=5,
                    rerank=True
                )

                return [
                    {
                        'content': result.memory,
                        'similarity': result.similarity,
                        'metadata': result.metadata
                    }
                    for result in results.results
                ]
            except Exception as e:
                print(f"顧客コンテキストの検索に失敗しました: {e}")
                raise

        def track_issue(self, customer_id: str, issue: Dict[str, str]) -> Dict:
            """顧客サポート案件を追跡"""
            try:
                issue_content = f"""案件: {issue['subject']}

    説明: {issue['description']}
    カテゴリ: {issue['category']}
    優先度: {issue['priority']}
    ステータス: {issue['status']}"""

                result = self.client.memories.add(
                    content=issue_content,
                    container_tag=self._get_container_tag(customer_id),
                    metadata={
                        'type': 'support_issue',
                        'subject': issue['subject'],
                        'category': issue['category'],
                        'priority': issue['priority'],
                        'status': issue['status'],
                        'createdAt': datetime.now().isoformat()
                    }
                )
                return result
            except Exception as e:
                print(f"案件の追跡に失敗しました: {e}")
                raise

        def update_issue_status(self, issue_id: str, status: str, resolution: Optional[str] = None) -> Dict:
            """サポート案件のステータスを更新"""
            try:
                # 元の案件を取得
                memory = self.client.memories.get(issue_id)
                customer_id = memory.container_tag.replace('customer_', '')

                update_content = f"案件更新: {memory.metadata.get('subject', '不明')}\nステータス変更: {status}"
                if resolution:
                    update_content += f"\n解決策: {resolution}"

                return self.add_interaction(customer_id, {
                    'type': 'ticket',
                    'content': update_content,
                    'channel': 'internal',
                    'outcome': 'resolved' if status == 'resolved' else 'pending',
                    'metadata': {
                        'originalIssueId': issue_id,
                        'statusUpdate': True
                    }
                })
            except Exception as e:
                print(f"案件ステータスの更新に失敗しました: {e}")
                raise
    ```
  </Tab>
</Tabs>

<div id="step-2-support-api-with-context">
  ### ステップ 2: コンテキスト対応の API を実装する
</div>

<Tabs>
  <Tab title="Next.js の API ルート">
    ```typescript app/api/support/chat/route.ts
    import { streamText } from 'ai'
    import { createOpenAI } from '@ai-sdk/openai'
    import { CustomerContextManager } from '@/lib/customer-context'

    const openai = createOpenAI({
      apiKey: process.env.OPENAI_API_KEY!
    })

    const contextManager = new CustomerContextManager()

    interface Customer {
      id: string
      name: string
      email: string
      tier: 'free' | 'pro' | 'enterprise'
      joinDate: string
    }

    export async function POST(request: Request) {
      const {
        message,
        customerId,
        customer,
        conversationHistory = [],
        agentId
      } = await request.json()

      try {
        // 顧客履歴とコンテキストを取得
        const [history, contextResults] = await Promise.all([
          contextManager.getCustomerHistory(customerId, 5),
          contextManager.searchCustomerContext(customerId, message)
        ])

        // 顧客コンテキストを構築
        const customerContext = `
    顧客プロフィール:
    - 名前: ${customer.name}
    - メール: ${customer.email}
    - プラン: ${customer.tier.toUpperCase()}
    - 登録日: ${customer.joinDate}

    最近のやり取り（直近5件）:
    ${history.map(h => `- ${h.timestamp}: ${h.type.toUpperCase()} - ${h.content.substring(0, 100)}...`).join('\n')}

    関連コンテキスト:
    ${contextResults.map(c => `- ${c.content.substring(0, 150)}... (関連度${(c.similarity * 100).toFixed(1)}%)`).join('\n')}
        `.trim()

        // エスカレーションが必要かどうかを判定
        const escalationKeywords = ['angry', 'frustrated', 'cancel', 'refund', 'legal', 'complaint', 'manager', 'supervisor']
        const needsEscalation = escalationKeywords.some(keyword =>
          message.toLowerCase().includes(keyword)
        ) || customer.tier === 'enterprise'

        const systemPrompt = `あなたは顧客の完全な履歴とコンテキストにアクセスできる親切なカスタマーサポートエージェントです。

    顧客コンテキスト:
    ${customerContext}

    サポートガイドライン:
    1. **パーソナライゼーション**: 顧客を名前で呼び、関連する場合はプラン・履歴を参照する
    2. **コンテキスト認識**: 過去のやり取りを踏まえて回答する
    3. **プラン別サービス**:
    - Free: 標準サポート、セルフサービスリソースへの案内
    - Pro: 優先サポート、詳細な説明、積極的な提案
    - Enterprise: ホワイトグローブサービス、即座のエスカレーション経路、専任対応

    4. **問題追跡**: 新しい問題の場合、カテゴリ分けする（請求、技術、アカウント、製品）
    5. **エスカレーション**: ${needsEscalation ? 'このやり取りは人間エージェントへのエスカレーションが必要な可能性があります - 有用な回答を提供しつつ、エスカレーション要約を準備してください' : '顧客が明確に人間エージェントを要求しない限り、直接対応してください'}

    回答スタイル:
    - プロフェッショナルかつ親しみやすく
    - 関連する場合は顧客履歴の具体的な詳細を参照
    - 実行可能な次のステップを提供
    - プランレベルに応じた関連リンクやリソースを含める

    問題を完全に解決できない場合は、人間エージェントへのエスカレーション用に明確な要約を準備してください。`

        const messages = [
          { role: 'system' as const, content: systemPrompt },
          ...conversationHistory,
          { role: 'user' as const, content: message }
        ]

        const result = await streamText({
          model: openai('gpt-5'),
          messages,
          temperature: 0.3,
          maxTokens: 800,
          onFinish: async (completion) => {
            // このやり取りを保存
            await contextManager.addInteraction(customerId, {
              type: 'chat',
              content: `Customer: ${message}\nAgent: ${completion.text}`,
              channel: 'web_chat',
              outcome: needsEscalation ? 'escalated' : 'resolved',
              agentId,
              metadata: {
                customerTier: customer.tier,
                needsEscalation,
                responseLength: completion.text.length
              }
            })

            // 新しい問題のように見える場合、追跡する
            if (message.length > 50 && !contextResults.some(c => c.similarity > 0.8)) {
              const issueCategory = categorizeIssue(message)
              const priority = determinePriority(customer.tier, message)

              await contextManager.trackIssue(customerId, {
                subject: message.substring(0, 100),
                description: message,
                category: issueCategory,
                priority,
                status: needsEscalation ? 'pending' : 'open'
              })
            }
          }
        })

        return result.toAIStreamResponse({
          data: {
            needsEscalation,
            customerTier: customer.tier,
            contextCount: contextResults.length
          }
        })

      } catch (error) {
        console.error('サポートチャットエラー:', error)
        return Response.json(
          { error: 'サポートリクエストの処理に失敗しました', details: error.message },
          { status: 500 }
        )
      }
    }

    function categorizeIssue(message: string): string {
      const categories = {
        billing: ['bill', 'charge', 'payment', 'refund', 'price', 'cost'],
        technical: ['error', 'bug', 'broken', 'not working', 'crash', 'slow'],
        account: ['login', 'password', 'access', 'settings', 'profile'],
        product: ['feature', 'how to', 'tutorial', 'help', 'guide']
      }

      const messageLower = message.toLowerCase()

      for (const [category, keywords] of Object.entries(categories)) {
        if (keywords.some(keyword => messageLower.includes(keyword))) {
          return category
        }
      }

      return 'general'
    }

    function determinePriority(tier: string, message: string): 'low' | 'medium' | 'high' | 'urgent' {
      const urgentKeywords = ['urgent', 'critical', 'emergency', 'down', 'broken']
      const highKeywords = ['important', 'asap', 'soon', 'problem']

      const messageLower = message.toLowerCase()

      if (urgentKeywords.some(keyword => messageLower.includes(keyword))) {
        return 'urgent'
      }

      if (tier === 'enterprise') {
        return highKeywords.some(keyword => messageLower.includes(keyword)) ? 'urgent' : 'high'
      }

      if (tier === 'pro') {
        return highKeywords.some(keyword => messageLower.includes(keyword)) ? 'high' : 'medium'
      }

      return 'low'
    }
    ```
  </Tab>

  <Tab title="Python FastAPI">
    ```python support_api.py
    from fastapi import FastAPI, HTTPException
    from fastapi.responses import StreamingResponse
    from pydantic import BaseModel
    from typing import List, Dict, Any, Optional
    import openai
    from customer_context import CustomerContextManager
    import json
    import os
    import re

    app = FastAPI()

    openai_client = openai.AsyncOpenAI(api_key=os.getenv("OPENAI_API_KEY"))
    context_manager = CustomerContextManager()

    class Customer(BaseModel):
        id: str
        name: str
        email: str
        tier: str
        joinDate: str

    class SupportRequest(BaseModel):
        message: str
        customerId: str
        customer: Customer
        conversationHistory: List[Dict[str, str]] = []
        agentId: Optional[str] = None

    def categorize_issue(message: str) -> str:
        """メッセージ内容に基づいてサポート問題を分類"""
        categories = {
            'billing': ['bill', 'charge', 'payment', 'refund', 'price', 'cost'],
            'technical': ['error', 'bug', 'broken', 'not working', 'crash', 'slow'],
            'account': ['login', 'password', 'access', 'settings', 'profile'],
            'product': ['feature', 'how to', 'tutorial', 'help', 'guide']
        }

        message_lower = message.lower()

        for category, keywords in categories.items():
            if any(keyword in message_lower for keyword in keywords):
                return category

        return 'general'

    def determine_priority(tier: str, message: str) -> str:
        """ティアとメッセージ内容に基づいて問題の優先度を決定"""
        urgent_keywords = ['urgent', 'critical', 'emergency', 'down', 'broken']
        high_keywords = ['important', 'asap', 'soon', 'problem']

        message_lower = message.lower()

        if any(keyword in message_lower for keyword in urgent_keywords):
            return 'urgent'

        if tier == 'enterprise':
            return 'urgent' if any(keyword in message_lower for keyword in high_keywords) else 'high'

        if tier == 'pro':
            return 'high' if any(keyword in message_lower for keyword in high_keywords) else 'medium'

        return 'low'

    @app.post("/support/chat")
    async def support_chat(request: SupportRequest):
        try:
            # 顧客履歴とコンテキストを取得
            history = context_manager.get_customer_history(request.customerId, 5)
            context_results = context_manager.search_customer_context(request.customerId, request.message)

            # 顧客コンテキストを構築
            customer_context = f"""
    顧客プロフィール:
    - 名前: {request.customer.name}
    - メール: {request.customer.email}
    - ティア: {request.customer.tier.upper()}
    - 登録日: {request.customer.joinDate}

    最近のやり取り（直近5件）:
    {chr(10).join([f"- {h['timestamp']}: {h['type'].upper()} - {h['content'][:100]}..." for h in history])}

    関連コンテキスト:
    {chr(10).join([f"- {c['content'][:150]}... ({c['similarity']*100:.1f}% 関連)" for c in context_results])}
            """.strip()

            # エスカレーションが必要かどうかを判定
            escalation_keywords = ['angry', 'frustrated', 'cancel', 'refund', 'legal', 'complaint', 'manager', 'supervisor']
            needs_escalation = any(keyword in request.message.lower() for keyword in escalation_keywords) or request.customer.tier == 'enterprise'

            system_prompt = f"""あなたは顧客の完全な履歴とコンテキストにアクセスできる親切なカスタマーサポートエージェントです。

    顧客コンテキスト:
    {customer_context}

    サポートガイドライン:
    1. **パーソナライゼーション**: 顧客を名前で呼び、関連する場合はティア/履歴を参照してください
    2. **コンテキスト認識**: 以前のやり取りを参考にして回答してください
    3. **ティア別サービス**:
    - Free: 標準サポート、セルフサービスリソースへの案内
    - Pro: 優先サポート、詳細な説明、積極的な提案
    - Enterprise: ホワイトグローブサービス、即座のエスカレーション経路、専任対応

    4. **問題追跡**: 新しい問題の場合は分類してください（請求、技術、アカウント、製品）
    5. **エスカレーション**: {'このやり取りは人間のエージェントへのエスカレーションが必要な可能性があります - 有用な回答を提供しつつエスカレーション要約を準備してください' if needs_escalation else '顧客が明確に人間のエージェントを要求しない限り直接対応してください'}

    回答スタイル:
    - プロフェッショナルかつ親しみやすく
    - 関連する場合は顧客履歴の具体的な詳細を参照
    - 実行可能な次のステップを提供
    - ティアレベルに応じた関連リンクやリソースを含める

    問題を完全に解決できない場合は、人間のエージェントへのエスカレーション用に明確な要約を準備してください。"""

            messages = [
                {"role": "system", "content": system_prompt},
                *request.conversationHistory,
                {"role": "user", "content": request.message}
            ]

            response = await openai_client.chat.completions.create(
                model="gpt-5",
                messages=messages,
                temperature=0.3,
                max_tokens=800,
                stream=True
            )

            async def generate():
                full_response = ""
                async for chunk in response:
                    if chunk.choices[0].delta.content:
                        content = chunk.choices[0].delta.content
                        full_response += content
                        yield f"data: {json.dumps({'content': content})}\n\n"

                # 完了後にやり取りを保存
                context_manager.add_interaction(request.customerId, {
                    'type': 'chat',
                    'content': f"顧客: {request.message}\nエージェント: {full_response}",
                    'channel': 'web_chat',
                    'outcome': 'escalated' if needs_escalation else 'resolved',
                    'agentId': request.agentId,
                    'metadata': {
                        'customerTier': request.customer.tier,
                        'needsEscalation': needs_escalation,
                        'responseLength': len(full_response)
                    }
                })

                # 新しい問題を追跡
                if len(request.message) > 50 and not any(c['similarity'] > 0.8 for c in context_results):
                    issue_category = categorize_issue(request.message)
                    priority = determine_priority(request.customer.tier, request.message)

                    context_manager.track_issue(request.customerId, {
                        'subject': request.message[:100],
                        'description': request.message,
                        'category': issue_category,
                        'priority': priority,
                        'status': 'pending' if needs_escalation else 'open'
                    })

                yield f"data: {json.dumps({'done': True, 'needsEscalation': needs_escalation})}\n\n"

            return StreamingResponse(generate(), media_type="text/plain")

        except Exception as e:
            raise HTTPException(status_code=500, detail=f"サポートチャットエラー: {str(e)}")

    if __name__ == "__main__":
        import uvicorn
        uvicorn.run(app, host="0.0.0.0", port=8000)
    ```
  </Tab>
</Tabs>

<div id="step-3-support-dashboard-interface">
  ### ステップ3：サポートダッシュボードのインターフェース
</div>

```tsx app/support/page.tsx
'use client'

import { useState, useEffect } from 'react'
import { useChat } from 'ai/react'
import { CustomerContextManager } from '@/lib/customer-context'

interface Customer {
  id: string
  name: string
  email: string
  tier: 'free' | 'pro' | 'enterprise'
  joinDate: string
}

interface SupportTicket {
  id: string
  subject: string
  status: 'open' | 'pending' | 'resolved' | 'closed'
  priority: 'low' | 'medium' | 'high' | 'urgent'
  category: string
  createdAt: string
}

export default function SupportDashboard() {
  const [selectedCustomer, setSelectedCustomer] = useState<Customer | null>(null)
  const [customerHistory, setCustomerHistory] = useState<any[]>([])
  const [tickets, setTickets] = useState<SupportTicket[]>([])
  const [showEscalation, setShowEscalation] = useState(false)
  const [agentId] = useState('agent_001') // 実際のアプリでは認証から取得

  const contextManager = new CustomerContextManager()

  const { messages, input, handleInputChange, handleSubmit, isLoading } = useChat({
    api: '/api/support/chat',
    body: {
      customerId: selectedCustomer?.id,
      customer: selectedCustomer,
      agentId
    },
    onFinish: (message, { data }) => {
      if (data?.needsEscalation) {
        setShowEscalation(true)
      }
      // 顧客履歴を更新
      if (selectedCustomer) {
        loadCustomerHistory(selectedCustomer.id)
      }
    }
  })

  // モック顧客データ - 実際のアプリでは顧客データベースから取得
  const mockCustomers: Customer[] = [
    {
      id: 'cust_001',
      name: 'Sarah Johnson',
      email: 'sarah@example.com',
      tier: 'pro',
      joinDate: '2023-06-15'
    },
    {
      id: 'cust_002',
      name: 'TechCorp Inc',
      email: 'support@techcorp.com',
      tier: 'enterprise',
      joinDate: '2022-03-20'
    },
    {
      id: 'cust_003',
      name: 'Mike Chen',
      email: 'mike@startup.com',
      tier: 'free',
      joinDate: '2024-01-10'
    }
  ]

  const loadCustomerHistory = async (customerId: string) => {
    try {
      const history = await contextManager.getCustomerHistory(customerId, 10)
      setCustomerHistory(history)
    } catch (error) {
      console.error('顧客履歴の読み込みに失敗しました:', error)
    }
  }

  const handleCustomerSelect = async (customer: Customer) => {
    setSelectedCustomer(customer)
    await loadCustomerHistory(customer.id)
    setShowEscalation(false)
  }

  const getTierColor = (tier: string) => {
    switch (tier) {
      case 'enterprise': return 'bg-purple-100 text-purple-800'
      case 'pro': return 'bg-blue-100 text-blue-800'
      case 'free': return 'bg-gray-100 text-gray-800'
      default: return 'bg-gray-100 text-gray-800'
    }
  }

  const getPriorityColor = (priority: string) => {
    switch (priority) {
      case 'urgent': return 'bg-red-100 text-red-800'
      case 'high': return 'bg-orange-100 text-orange-800'
      case 'medium': return 'bg-yellow-100 text-yellow-800'
      case 'low': return 'bg-green-100 text-green-800'
      default: return 'bg-gray-100 text-gray-800'
    }
  }

  return (
    <div className="h-screen flex">
      {/* 顧客リストサイドバー */}
      <div className="w-80 bg-white border-r border-gray-200 overflow-y-auto">
        <div className="p-4 border-b">
          <h2 className="text-lg font-semibold">顧客</h2>
        </div>
        <div className="divide-y divide-gray-200">
          {mockCustomers.map((customer) => (
            <div
              key={customer.id}
              onClick={() => handleCustomerSelect(customer)}
              className={`p-4 cursor-pointer hover:bg-gray-50 ${
                selectedCustomer?.id === customer.id ? 'bg-blue-50 border-r-2 border-blue-500' : ''
              }`}
            >
              <div className="flex items-center justify-between mb-2">
                <div className="font-medium text-gray-900">{customer.name}</div>
                <span className={`px-2 py-1 text-xs rounded-full ${getTierColor(customer.tier)}`}>
                  {customer.tier}
                </span>
              </div>
              <div className="text-sm text-gray-600">{customer.email}</div>
              <div className="text-xs text-gray-500 mt-1">
                登録日 {customer.joinDate}
              </div>
            </div>
          ))}
        </div>
      </div>

      {/* メインコンテンツ */}
      <div className="flex-1 flex flex-col">
        {selectedCustomer ? (
          <>
            {/* 顧客ヘッダー */}
            <div className="bg-white border-b border-gray-200 p-4">
              <div className="flex items-center justify-between">
                <div>
                  <h1 className="text-xl font-semibold">{selectedCustomer.name}</h1>
                  <p className="text-gray-600">{selectedCustomer.email}</p>
                </div>
                <div className="flex items-center space-x-4">
                  <span className={`px-3 py-1 text-sm rounded-full ${getTierColor(selectedCustomer.tier)}`}>
                    {selectedCustomer.tier.toUpperCase()} 顧客
                  </span>
                  {showEscalation && (
                    <div className="bg-red-100 text-red-800 px-3 py-1 text-sm rounded-full">
                      エスカレーション要
                    </div>
                  )}
                </div>
              </div>
            </div>

            <div className="flex-1 flex">
              {/* チャットエリア */}
              <div className="flex-1 flex flex-col">
                {/* メッセージ */}
                <div className="flex-1 overflow-y-auto p-4 space-y-4">
                  {messages.length === 0 && (
                    <div className="text-center py-8 text-gray-500">
                      <div className="text-lg font-medium">サポートチャットへようこそ</div>
                      <p className="mt-2">
                        {selectedCustomer.name}との会話を開始
                      </p>
                      <div className="mt-4 text-sm">
                        <p><strong>顧客ティア:</strong> {selectedCustomer.tier}</p>
                        <p><strong>登録日:</strong> {selectedCustomer.joinDate}</p>
                      </div>
                    </div>
                  )}

                  {messages.map((message) => (
                    <div
                      key={message.id}
                      className={`flex ${
                        message.role === 'user' ? 'justify-end' : 'justify-start'
                      }`}
                    >
                      <div
                        className={`max-w-2xl p-4 rounded-lg ${
                          message.role === 'user'
                            ? 'bg-blue-500 text-white'
                            : 'bg-gray-100 text-gray-900'
                        }`}
                      >
                        <div className="flex items-center space-x-2 mb-2">
                          <span className="text-sm font-medium">
                            {message.role === 'user' ? selectedCustomer.name : 'サポートエージェント'}
                          </span>
                          <span className="text-xs opacity-75">
                            {new Date().toLocaleTimeString()}
                          </span>
                        </div>
                        <div className="whitespace-pre-wrap">{message.content}</div>
                      </div>
                    </div>
                  ))}

                  {isLoading && (
                    <div className="flex justify-start">
                      <div className="max-w-2xl p-4 bg-gray-100 rounded-lg">
                        <div className="flex items-center space-x-2">
                          <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
                          <span className="text-sm">エージェントが入力中...</span>
                        </div>
                      </div>
                    </div>
                  )}
                </div>

                {/* チャット入力 */}
                <div className="border-t border-gray-200 p-4">
                  <form onSubmit={handleSubmit} className="flex space-x-2">
                    <input
                      value={input}
                      onChange={handleInputChange}
                      placeholder={`${selectedCustomer.name}に返信...`}
                      className="flex-1 p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                      disabled={isLoading}
                    />
                    <button
                      type="submit"
                      disabled={isLoading || !input.trim()}
                      className="px-6 py-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed"
                    >
                      送信
                    </button>
                  </form>
                </div>
              </div>

              {/* 顧客履歴サイドバー */}
              <div className="w-80 bg-gray-50 border-l border-gray-200 overflow-y-auto">
                <div className="p-4 border-b bg-white">
                  <h3 className="font-medium">顧客履歴</h3>
                </div>
                <div className="p-4 space-y-3">
                  {customerHistory.map((interaction, index) => (
                    <div key={index} className="bg-white p-3 rounded-lg border text-sm">
                      <div className="flex items-center justify-between mb-2">
                        <span className="font-medium capitalize">{interaction.type}</span>
                        <span className="text-xs text-gray-500">
                          {new Date(interaction.timestamp).toLocaleDateString()}
                        </span>
                      </div>
                      <p className="text-gray-700 line-clamp-3">
                        {interaction.content.length > 100
                          ? `${interaction.content.substring(0, 100)}...`
                          : interaction.content
                        }
                      </p>
                      {interaction.outcome && (
                        <div className="mt-2">
                          <span className={`text-xs px-2 py-1 rounded ${
                            interaction.outcome === 'resolved'
                              ? 'bg-green-100 text-green-800'
                              : interaction.outcome === 'escalated'
                              ? 'bg-red-100 text-red-800'
                              : 'bg-yellow-100 text-yellow-800'
                          }`}>
                            {interaction.outcome}
                          </span>
                        </div>
                      )}
                    </div>
                  ))}

                  {customerHistory.length === 0 && (
                    <div className="text-center py-8 text-gray-500">
                      <p>過去のやり取りはありません</p>
                    </div>
                  )}
                </div>
              </div>
            </div>
          </>
        ) : (
          <div className="flex-1 flex items-center justify-center text-gray-500">
            <div className="text-center">
              <div className="text-lg font-medium">カスタマーサポート</div>
              <p className="mt-2">顧客を選択してサポート対応を開始してください</p>
            </div>
          </div>
        )}
      </div>
    </div>
  )
}
```

<div id="testing-your-support-system">
  ## サポートシステムのテスト方法
</div>

<div id="step-4-test-support-scenarios">
  ### ステップ 4: サポートシナリオのテスト
</div>

1. **顧客ティアのテスト**:
   - Free ティア: 基本的な応答、セルフサービス型のガイダンス
   - Pro ティア: 詳細な支援、積極的な提案
   - Enterprise: きめ細かな対応、エスカレーション体制の整備

2. **メモリーとコンテキストのテスト**:
   - 過去の問題について質問する
   - 顧客の嗜好を参照する
   - 未解決チケットをフォローアップする

3. **エスカレーショントリガーのテスト**:
   - "angry"、"manager"、"refund" といったキーワードを使用する
   - エンタープライズ顧客の自動エスカレーションを検証する

この包括的なカスタマーサポート向けレシピは、パーソナライズされたサービスによって顧客満足度を高める、知的でコンテキストを理解するサポートシステムを構築するための土台となります。

---

*このレシピは、固有のサポートワークフローや顧客ニーズに合わせてカスタマイズしてください。*