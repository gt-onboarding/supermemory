---
title: "Python SDK"
sidebarTitle: "Python"
description: "जानें कि Python के साथ Supermemory का उपयोग कैसे करें"
---

<div id="installation">
  ## इंस्टॉलेशन
</div>

```sh
# PyPI से install करें
pip install --pre supermemory
```


<div id="usage">
  ## उपयोग
</div>

```python
import os
from supermemory import Supermemory

client = supermemory(
    api_key=os.environ.get("SUPERMEMORY_API_KEY"),  # यह डिफ़ॉल्ट है और इसे छोड़ा जा सकता है
)

response = client.search.execute(
    q="python से संबंधित दस्तावेज़",
)
print(response.results)
```

हालाँकि आप `api_key` नाम का कीवर्ड आर्गुमेंट दे सकते हैं,
हम [python-dotenv](https://pypi.org/project/python-dotenv/) का उपयोग करने की सलाह देते हैं
ताकि आप अपनी `.env` फ़ाइल में `SUPERMEMORY_API_KEY="My API Key"` जोड़ सकें,
जिससे आपकी API कुंजी सोर्स कंट्रोल में स्टोर न हो।


<div id="async-usage">
  ## असिंक्रोनस उपयोग
</div>

बस `supermemory` के बजाय `AsyncSupermemory` इम्पोर्ट करें और हर API कॉल के साथ `await` का उपयोग करें:

```python
import os
import asyncio
from supermemory import AsyncSupermemory

client = AsyncSupermemory(
    api_key=os.environ.get("SUPERMEMORY_API_KEY"),  # यह डिफ़ॉल्ट है और इसे छोड़ा जा सकता है
)


async def main() -> None:
    response = await client.search.execute(
        q="python से संबंधित दस्तावेज़",
    )
    print(response.results)


asyncio.run(main())
```

अन्य सभी मामलों में, synchronous और asynchronous क्लाइंट्स की कार्यक्षमता समान है।


<div id="using-types">
  ## प्रकारों का उपयोग
</div>

नेस्टेड रिक्वेस्ट पैरामीटर [TypedDicts](https://docs.python.org/3/library/typing.html#typing.TypedDict) होते हैं। रेस्पॉन्स [Pydantic models](https://docs.pydantic.dev) होते हैं, जो निम्नलिखित के लिए हेल्पर मेथड भी प्रदान करते हैं:

- JSON में सीरियलाइज़ करना, `model.to_json()`
- डिक्शनरी में बदलना, `model.to_dict()`

टाइप्ड रिक्वेस्ट और रेस्पॉन्स आपके एडिटर में ऑटोकंप्लीट और डॉक्यूमेंटेशन उपलब्ध कराते हैं। यदि आप VS Code में टाइप एरर पहले से देखना चाहते हैं ताकि बग जल्दी पकड़े जा सकें, तो `python.analysis.typeCheckingMode` को `basic` पर सेट करें।

<div id="file-uploads">
  ## फ़ाइल अपलोड
</div>

फ़ाइल अपलोड से संबंधित अनुरोध पैरामीटर `bytes`, [`PathLike`](https://docs.python.org/3/library/os.html#os.PathLike) का एक इंस्टेंस, या `(filename, contents, media type)` के ट्यूपल के रूप में पास किए जा सकते हैं।

```python
from pathlib import Path
from supermemory import Supermemory

client = supermemory()

client.memories.upload_file(
    file=Path("/path/to/file"),
)
```

Async क्लाइंट बिल्कुल वही इंटरफ़ेस उपयोग करता है। यदि आप [`PathLike`](https://docs.python.org/3/library/os.html#os.PathLike) इंस्टेंस पास करते हैं, तो फ़ाइल की सामग्री अपने आप असिंक्रोनस रूप से पढ़ी जाएगी।


<div id="handling-errors">
  ## त्रुटियों का प्रबंधन
</div>

जब लाइब्रेरी API से कनेक्ट नहीं कर पाती (जैसे नेटवर्क समस्याओं या टाइमआउट के कारण), तो `supermemory.APIConnectionError` की एक उपवर्ग (subclass) उठाई जाती है।

जब API non-success status code लौटाती है (अर्थात 4xx या 5xx response), तो `supermemory.APIStatusError` की एक उपवर्ग उठाई जाती है, जिसमें `status_code` और `response` गुण होते हैं।

सभी त्रुटियाँ `supermemory.APIError` से विरासत में मिलती हैं।

```python
import supermemory
from supermemory import Supermemory

client = supermemory()

try:
    client.memories.add(
        content="यह मशीन लर्निंग अवधारणाओं के बारे में एक विस्तृत लेख है...",
    )
except supermemory.APIConnectionError as e:
    print("सर्वर तक पहुंच नहीं हो सकी")
    print(e.__cause__)  # एक अंतर्निहित Exception, संभावित रूप से httpx के भीतर उठाया गया।
except supermemory.RateLimitError as e:
    print("429 status code प्राप्त हुआ; हमें थोड़ा इंतज़ार करना चाहिए।")
except supermemory.APIStatusError as e:
    print("कोई अन्य non-200-range status code प्राप्त हुआ")
    print(e.status_code)
    print(e.response)
```

त्रुटि कोड इस प्रकार हैं:

| Status Code | Error Type                 |
| ----------- | -------------------------- |
| 400         | `BadRequestError`          |
| 401         | `AuthenticationError`      |
| 403         | `PermissionDeniedError`    |
| 404         | `NotFoundError`            |
| 422         | `UnprocessableEntityError` |
| 429         | `RateLimitError`           |
| &gt;=500       | `InternalServerError`      |
| N/A         | `APIConnectionError`       |


<div id="retries">
  ### पुनः प्रयास
</div>

कुछ त्रुटियाँ डिफ़ॉल默认 रूप से 2 बार स्वचालित रूप से पुनः प्रयास की जाती हैं, एक छोटे एक्सपोनेंशियल बैकऑफ के साथ।
कनेक्शन त्रुटियाँ (जैसे नेटवर्क कनेक्टिविटी समस्या), 408 Request Timeout, 409 Conflict,
429 Rate Limit, और &gt;=500 Internal errors सभी का डिफ़ॉल्ट रूप से पुनः प्रयास किया जाता है।

आप `max_retries` विकल्प का उपयोग करके पुनः प्रयास सेटिंग्स को कॉन्फ़िगर या अक्षम कर सकते हैं:

```python
from supermemory import Supermemory

# सभी अनुरोधों के लिए डिफ़ॉल्ट कॉन्फ़िगर करें:
client = supermemory(
    # डिफ़ॉल्ट 2 है
    max_retries=0,
)

# या, प्रति-अनुरोध कॉन्फ़िगर करें:
client.with_options(max_retries=5).memories.add(
    content="यह मशीन लर्निंग अवधारणाओं के बारे में एक विस्तृत लेख है...",
)
```


<div id="timeouts">
  ### टाइमआउट्स
</div>

डिफ़ॉल्ट रूप से अनुरोध 1 मिनट बाद टाइम आउट हो जाते हैं। आप इसे `timeout` विकल्प से कॉन्फ़िगर कर सकते हैं,
जो एक फ्लोट या [`httpx.Timeout`](https://www.python-httpx.org/advanced/#fine-tuning-the-configuration) ऑब्जेक्ट स्वीकार करता है:

```python
from supermemory import Supermemory

# सभी अनुरोधों के लिए डिफ़ॉल्ट कॉन्फ़िगर करें:
client = supermemory(
    # 20 सेकंड (डिफ़ॉल्ट 1 मिनट है)
    timeout=20.0,
)

# अधिक विस्तृत नियंत्रण:
client = supermemory(
    timeout=httpx.Timeout(60.0, read=5.0, write=10.0, connect=2.0),
)

# प्रति-अनुरोध ओवरराइड:
client.with_options(timeout=5.0).memories.add(
    content="यह मशीन लर्निंग अवधारणाओं के बारे में एक विस्तृत लेख है...",
)
```

टाइमआउट होने पर `APITimeoutError` थ्रो किया जाता है।

ध्यान दें कि टाइमआउट हुए अनुरोधों को [डिफ़ॉल्ट रूप से दो बार रीट्राई किया जाता है](#retries)।


<div id="advanced">
  ## उन्नत
</div>

<div id="logging">
  ### लॉगिंग
</div>

हम स्टैंडर्ड लाइब्रेरी [`logging`](https://docs.python.org/3/library/logging.html) मॉड्यूल का उपयोग करते हैं।

आप पर्यावरण वेरिएबल `SUPERMEMORY_LOG` को `info` पर सेट करके लॉगिंग सक्षम कर सकते हैं।

```shell
$ export SUPERMEMORY_LOG=info
```

या अधिक विस्तृत लॉगिंग के लिए `debug` पर सेट करें।


<div id="how-to-tell-whether-none-means-null-or-missing">
  ### कैसे पहचानें कि `None` का अर्थ `null` है या फ़ील्ड गायब है
</div>

किसी API response में कोई field या तो स्पष्ट रूप से `null` हो सकती है या पूरी तरह अनुपस्थित; दोनों ही स्थितियों में इस लाइब्रेरी में उसका मान `None` होता है। आप इन दोनों स्थितियों में भेद `.model_fields_set` से कर सकते हैं:

```py
if response.my_field is None:
  if 'my_field' not in response.model_fields_set:
    print('JSON मिला जैसे {}, जिसमें "my_field" key बिल्कुल मौजूद नहीं है।')
  else:
    print('JSON मिला जैसे {"my_field": null}।')
```


<div id="accessing-raw-response-data-eg-headers">
  ### रॉ प्रतिक्रिया डेटा तक पहुंच (जैसे हेडर्स)
</div>

&quot;रॉ&quot; Response ऑब्जेक्ट तक किसी भी HTTP मेथड कॉल से पहले `.with_raw_response.` जोड़कर पहुंचा जा सकता है, उदाहरण के लिए,

```py
from supermemory import Supermemory

client = supermemory()
response = client.memories.with_raw_response.add(
    content="यह मशीन लर्निंग अवधारणाओं के बारे में एक विस्तृत लेख है...",
)
print(response.headers.get('X-My-Header'))

memory = response.parse()  # वह ऑब्जेक्ट प्राप्त करें जो `memories.add()` वापस करता होगा
print(memory.id)
```

ये मेथड एक [`APIResponse`](https://github.com/supermemoryai/python-sdk/tree/main/src/supermemory/_response.py) ऑब्जेक्ट लौटाते हैं।

Async क्लाइंट इसी संरचना वाला [`AsyncAPIResponse`](https://github.com/supermemoryai/python-sdk/tree/main/src/supermemory/_response.py) लौटाता है; फर्क सिर्फ इतना है कि रिस्पॉन्स सामग्री पढ़ने के लिए `await`-योग्य मेथड उपलब्ध होते हैं।


<div id="with_streaming_response">
  #### `.with_streaming_response`
</div>

ऊपर दिया गया इंटरफ़ेस अनुरोध करते समय पूरे response body को तुरन्त पढ़ लेता है, जो हर बार आवश्यक नहीं होता।

Response body को स्ट्रीम करने के लिए `.with_streaming_response` का उपयोग करें। यह एक context manager की आवश्यकता करता है और केवल तब response body पढ़ता है जब आप `.read()`, `.text()`, `.json()`, `.iter_bytes()`, `.iter_text()`, `.iter_lines()` या `.parse()` कॉल करते हैं। Async client में, ये async methods होते हैं।

```python
with client.memories.with_streaming_response.add(
    content="यह मशीन लर्निंग की अवधारणाओं पर एक विस्तृत लेख है...",
) as response:
    print(response.headers.get("X-My-Header"))

    for line in response.iter_lines():
        print(line)
```

रेस्पांस को भरोसेमंद तरीके से बंद करने के लिए कॉन्टेक्स्ट मैनेजर आवश्यक है।


<div id="making-customundocumented-requests">
  ### कस्टम/अप्रलेखित अनुरोध करना
</div>

यह लाइब्रेरी प्रलेखित API तक आसान पहुँच के लिए टाइप्ड है।

यदि आपको अप्रलेखित endpoints, params या response properties तक पहुँचना हो, तब भी आप इस लाइब्रेरी का उपयोग कर सकते हैं।

<div id="undocumented-endpoints">
  #### बिना प्रलेखित endpoints
</div>

अप्रलेखित endpoints पर अनुरोध करने के लिए, आप `client.get`, `client.post` और अन्य
HTTP verbs का उपयोग कर सकते हैं। इस अनुरोध के दौरान क्लाइंट पर सेट विकल्पों (जैसे retries) का सम्मान किया जाएगा।

```py
import httpx

response = client.post(
    "/foo",
    cast_to=httpx.Response,
    body={"my_param": True},
)

print(response.headers.get("x-foo"))
```


<div id="undocumented-request-params">
  #### बिना दस्तावेज़ वाले अनुरोध पैरामीटर
</div>

यदि आप स्पष्ट रूप से कोई अतिरिक्त पैरामीटर भेजना चाहते हैं, तो आप `extra_query`, `extra_body` और `extra_headers` अनुरोध विकल्पों के साथ ऐसा कर सकते हैं।

<div id="undocumented-response-properties">
  #### अविदित/दस्तावेज़-रहित प्रतिक्रिया गुण
</div>

दस्तावेज़-रहित प्रतिक्रिया गुणों तक पहुँचने के लिए, आप `response.unknown_prop` जैसे अतिरिक्त फ़ील्ड तक पहुँच सकते हैं। आप Pydantic मॉडल पर सभी अतिरिक्त फ़ील्ड को एक dict के रूप में भी प्राप्त कर सकते हैं
[`response.model_extra`](https://docs.pydantic.dev/latest/api/base_model/#pydantic.BaseModel.model_extra) के साथ।

<div id="configuring-the-http-client">
  ### HTTP क्लाइंट को कॉन्फ़िगर करना
</div>

आप अपने उपयोग-केस के अनुसार इसे अनुकूलित करने के लिए [httpx client](https://www.python-httpx.org/api/#client) को सीधे ओवरराइड कर सकते हैं, जैसे:

* [proxies](https://www.python-httpx.org/advanced/proxies/) का समर्थन
* कस्टम [transports](https://www.python-httpx.org/advanced/transports/)
* अतिरिक्त [advanced](https://www.python-httpx.org/advanced/clients/) क्षमताएँ

```python
import httpx
from supermemory import Supermemory, DefaultHttpxClient

client = supermemory(
    # या `SUPERMEMORY_BASE_URL` env var का उपयोग करें
    base_url="http://my.test.server.example.com:8083",
    http_client=DefaultHttpxClient(
        proxy="http://my.test.proxy.example.com",
        transport=httpx.HTTPTransport(local_address="0.0.0.0"),
    ),
)
```

आप `with_options()` का उपयोग करके प्रत्येक रिक्वेस्ट के आधार पर क्लाइंट को कस्टमाइज़ कर सकते हैं:

```python
client.with_options(http_client=DefaultHttpxClient(...))
```


<div id="managing-http-resources">
  ### HTTP संसाधनों का प्रबंधन
</div>

डिफ़ॉल्ट रूप से, जब क्लाइंट [garbage collected](https://docs.python.org/3/reference/datamodel.html#object.__del__) होता है, तो लाइब्रेरी अंतर्निहित HTTP कनेक्शनों को बंद कर देती है। आप चाहें तो `.close()` मेथड का उपयोग करके क्लाइंट को मैन्युअल रूप से बंद कर सकते हैं, या ऐसे कॉन्टेक्स्ट मैनेजर के साथ जो बाहर निकलते समय इसे बंद कर देता है।

```py
from supermemory import Supermemory

with supermemory() as client:
  # यहाँ requests करें
  ...

# HTTP client अब बंद हो गया है
```


<div id="versioning">
  ## संस्करणिंग
</div>

यह पैकेज सामान्यतः [SemVer](https://semver.org/spec/v2.0.0.html) नियमों का पालन करता है, हालांकि कुछ पिछड़ी-असंगत बदलाव माइनर संस्करणों के रूप में जारी किए जा सकते हैं:

1. ऐसे बदलाव जो केवल स्थिर प्रकारों को प्रभावित करते हैं और रनटाइम व्यवहार नहीं तोड़ते।
2. लाइब्रेरी के आंतरिक हिस्सों में बदलाव, जो तकनीकी रूप से सार्वजनिक हैं, लेकिन बाहरी उपयोग के लिए न अभिप्रेत हैं न ही प्रलेखित। _(यदि आप ऐसे आंतरिक हिस्सों पर निर्भर हैं, तो कृपया हमें सूचित करने के लिए एक GitHub issue खोलें.)_
3. ऐसे बदलाव जिनसे व्यवहार में अधिकांश उपयोगकर्ताओं पर प्रभाव पड़ने की उम्मीद नहीं है।

हम पिछड़ी संगतता को गंभीरता से लेते हैं और यह सुनिश्चित करने के लिए कड़ी मेहनत करते हैं कि आप सुगम अपग्रेड अनुभव पर भरोसा कर सकें।

हम आपके फीडबैक के इच्छुक हैं; कृपया प्रश्नों, बग्स, या सुझावों के साथ एक [issue](https://www.github.com/supermemoryai/python-sdk/issues) खोलें।

<div id="determining-the-installed-version">
  ### इंस्टॉल किए गए संस्करण की जाँच
</div>

यदि आपने नवीनतम संस्करण में अपग्रेड किया है, लेकिन अपेक्षित नई सुविधाएँ नहीं दिख रही हैं, तो संभव है कि आपका Python environment अभी भी पुराने संस्करण का उपयोग कर रहा हो।

आप रनटाइम पर उपयोग हो रहे संस्करण की जाँच इस तरह कर सकते हैं:

```py
import supermemory
print(supermemory.__version__)
```


<div id="requirements">
  ## आवश्यकताएँ
</div>

Python 3.8 या उससे नवीनतर।