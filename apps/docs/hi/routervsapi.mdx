---
title: "Memory API बनाम Router — मुझे किसका उपयोग करना चाहिए?"
sidebarTitle: "Memory API बनाम Router"
description: "अपने LLMs में दीर्घकालिक स्मृति जोड़ने के दो तरीके। भीतर वही इंजन। स्पीड (Router) या नियंत्रण (Memory API) चुनें, या दोनों साथ में उपयोग करें।"
---

<Tip>
### <strong>संक्षेप में</strong>
- <strong>Memory API:</strong> आप स्वयं संग्रहीत स्मृतियाँ ingest/search/filter करते हैं और तय करते हैं कि प्रॉम्प्ट में क्या जाएगा। प्रोडक्शन ऐप्स और कस्टम रिट्रीवल के लिए अधिकतम नियंत्रण। <br/>
- <strong>Memory Router:</strong> अपना मौजूदा LLM क्लाइंट रखें और बस उसे Supermemory की ओर पॉइंट करें। हम स्वतः प्रासंगिक संग्रहीत स्मृतियाँ लाते हैं और उन्हें आपके प्रॉम्प्ट में जोड़ते हैं। <br />

दोनों भीतर एक ही स्मृति इंजन का उपयोग करते हैं, और एक सामान्य कुंजी (`user_id`) साझा करते हैं। इसलिए, जो कुछ भी आप API के माध्यम से स्टोर करते हैं, वह Router के लिए उपलब्ध है, और इसके विपरीत, बशर्ते `user_id` मेल खाता हो।
</Tip>

हम पहले बताएंगे कि Router कैसे काम करता है, क्योंकि API काफी सीधी है।

![](./images/infinite-context.png)

आप अपने LLM को एक अनुरोध भेजते हैं, और Supermemory एक प्रॉक्सी की तरह कार्य करता है। Router संदेश से अनावश्यक संदर्भ अपने आप हटा देता है, उपयोगकर्ता की संग्रहीत स्मृतियों से अतिरिक्त प्रासंगिक संदर्भ खोजता है, उसे प्रॉम्प्ट में जोड़ता है, और LLM को भेज देता है। 

यह नई संग्रहीत स्मृतियाँ भी asynchronous रूप से लिखता है, ताकि आपका संदर्भ बिना किसी रुकावट के बढ़ता रहे। Router खास तौर पर चैट एप्लिकेशनों में conversational स्मृति के लिए बनाया गया है, और इसका लाभ तब सबसे अधिक दिखता है जब आपकी बातचीत बहुत लंबी हो जाती है।

आपके लिए, इसके परिणाम:

- कोई कोड refactoring नहीं — बस base URL को Supermemory द्वारा प्रदान किए गए से बदल दें। अधिक जानने के लिए quickstart पढ़ें।
- लंबे थ्रेड रिट्रीवल के कारण बेहतर चैटबॉट प्रदर्शन, जब बातचीत मॉडल विंडो से आगे निकल जाए।
- हमारी स्वचालित चंकिंग और संदर्भ प्रबंधन के कारण लागत में बचत।

दूसरी ओर, API एक पूर्ण-विशेषताओं वाली API है जिसे आप अपने ऐप में Documents ingest करने, स्मृतियाँ बनाने, उन्हें खोजने, Reranking करने आदि के लिए सूक्ष्म नियंत्रण के साथ कॉल कर सकते हैं। Router हमारी API के ऊपर बनाया गया है।

तकनीकी रूप से, आप हमारी API के ऊपर अपना खुद का Memory Router भी बना सकते हैं, लेकिन उसमें वही one-line integration, उपयोग में सरलता, न्यूनतम latency, और बुद्धिमान टोकन बजटिंग नहीं होगी।

फिर से, दोनों भीतर एक ही स्मृति इंजन का उपयोग करते हैं, इसलिए आपकी संग्रहीत स्मृतियाँ दोनों प्रोडक्ट्स में उपलब्ध हैं।

आपके विशेष उपयोग केस के लिए किसका उपयोग करना है, यह तय करने के लिए एक त्वरित 30-सेकंड फ्लो:

- <strong> क्या आपके पास पहले से एक काम करता LLM चैट है और आप बस चाहते हैं कि वह याद रखे? </strong> Router से शुरू करें.


- <strong> नया ऐप बना रहे हैं या सख्त tenancy, filters, ranking, या कस्टम प्रॉम्प्ट्स चाहिए? </strong> Memory API पर जाएँ.


- <strong> दोनों चाहिए? </strong> API के माध्यम से ingest करें, Router के जरिए चैट करें; user_id को सुसंगत रखें.


- <strong> अब भी अनिश्चित हैं? </strong> पहले Router पर पायलट करें, फिर जैसे-जैसे अधिक नियंत्रण चाहिए, फ्लो के हिस्सों को API पर शिफ्ट करें।

अब, अपने ऐप में 5 मिनट के भीतर API/Router इंटीग्रेट करने के लिए quickstart पर जाएँ।

<div id="faqs">
  ## FAQs
</div>

<AccordionGroup>
  <Accordion title="क्या Router पर्दे के पीछे सिर्फ Memory API को कॉल करता है?">
    अवधारणात्मक रूप से, हाँ। Router वही Supermemory इंजन ऑपरेशंस (retrieve, re-rank, budget, cite) को ऑर्केस्ट्रेट करता है और उन्हें आपके मॉडल कॉल के चारों ओर लपेट देता है।
  </Accordion>
  <Accordion title="क्या Router नई स्मृतियाँ अपने आप संग्रहीत करता है?">
    कर सकता है। create-memory चरण असिंक्रोनस है, इसलिए उपयोगकर्ता की प्रतिक्रिया में देरी नहीं होती।
  </Accordion>
  <Accordion title="Router और API के बीच उपयोगकर्ता की स्मृति की पहचान किससे होती है?">
    <code>user_id</code>. एक ही स्मृति पूल साझा करने के लिए इसे Router और API कॉल्स में समान रखें।
  </Accordion>
</AccordionGroup>