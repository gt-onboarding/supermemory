---
title: "Document Q&A System"
description: "ऐसा चैटबॉट बनाएं जो आपके Documents से प्रश्नों के उत्तर उद्धरणों और स्रोत संदर्भों सहित दे"
---

एक शक्तिशाली Document Q&A सिस्टम बनाएं जो PDFs, टेक्स्ट फाइलें और वेब पेज इनजेस्ट कर सके, और फिर सटीक उद्धरणों के साथ प्रश्नों के उत्तर दे। डॉक्यूमेंटेशन साइट्स, रिसर्च डेटाबेस या आंतरिक नॉलेज बेस के लिए उत्तम।

<div id="what-youll-build">
  ## आप क्या बनाएंगे
</div>

एक दस्तावेज़ Q&A सिस्टम जो:

- **कई फ़ाइल प्रकार इन्गेस्ट करता है** (PDFs, DOCX, टेक्स्ट, URLs)
- **प्रश्नों के सटीक उत्तर देता है** स्रोत उद्धरणों के साथ
- **स्रोत संदर्भ प्रदान करता है** पृष्ठ संख्याओं और दस्तावेज़ शीर्षक के साथ
- **फॉलो‑अप प्रश्नों को संभालता है** वार्तालाप संदर्भ के साथ
- **अलग‑अलग विषयों के लिए** कई दस्तावेज़ संग्रहों का समर्थन करता है

<div id="prerequisites">
  ## पूर्वापेक्षाएँ
</div>

- Node.js 18+ या Python 3.8+
- Supermemory API कुंजी
- OpenAI API कुंजी
- फ़ाइल हैंडलिंग की मूलभूत समझ

<div id="implementation">
  ## कार्यान्वयन
</div>

<div id="step-1-document-processing-system">
  ### चरण 1: दस्तावेज़ प्रसंस्करण प्रणाली
</div>

<Tabs>
  <Tab title="Next.js">
    ```typescript lib/document-processor.ts
    import { Supermemory } from 'supermemory'

    const client = new Supermemory({
      apiKey: process.env.SUPERMEMORY_API_KEY!
    })

    interface DocumentUpload {
      file: File
      collection: string
      metadata?: Record<string, any>
    }

    export class DocumentProcessor {
      async uploadDocument({ file, collection, metadata = {} }: DocumentUpload) {
        try {
          const formData = new FormData()
          formData.append('file', file)
          formData.append('containerTags', JSON.stringify([collection]))
          formData.append('metadata', JSON.stringify({
            originalName: file.name,
            fileType: file.type,
            uploadedAt: new Date().toISOString(),
            ...metadata
          }))

          const response = await fetch('/api/upload-document', {
            method: 'POST',
            body: formData
          })

          if (!response.ok) {
            throw new Error(`अपलोड विफल: ${response.statusText}`)
          }

          return await response.json()
        } catch (error) {
          console.error('Document अपलोड त्रुटि:', error)
          throw error
        }
      }

      async uploadURL({ url, collection, metadata = {} }: { url: string, collection: string, metadata?: Record<string, any> }) {
        try {
          const result = await client.memories.add({
            content: url,
            containerTag: collection,
            metadata: {
              type: 'url',
              originalUrl: url,
              uploadedAt: new Date().toISOString(),
              ...metadata
            }
          })

          return result
        } catch (error) {
          console.error('URL अपलोड त्रुटि:', error)
          throw error
        }
      }

      async getDocumentStatus(documentId: string) {
        try {
          const memory = await client.memories.get(documentId)
          return {
            id: memory.id,
            status: memory.status,
            title: memory.title,
            progress: memory.metadata?.progress || 0
          }
        } catch (error) {
          console.error('Status जांच त्रुटि:', error)
          throw error
        }
      }

      async listDocuments(collection: string) {
        try {
          const memories = await client.memories.list({
            containerTags: [collection],
            limit: 50,
            sort: 'updatedAt',
            order: 'desc'
          })

          return memories.memories.map(memory => ({
            id: memory.id,
            title: memory.title || memory.metadata?.originalName || 'शीर्षकहीन',
            type: memory.metadata?.fileType || memory.metadata?.type || 'अज्ञात',
            uploadedAt: memory.metadata?.uploadedAt,
            status: memory.status,
            url: memory.metadata?.originalUrl
          }))
        } catch (error) {
          console.error('Documents सूची त्रुटि:', error)
          throw error
        }
      }
    }
    ```

    ```typescript app/api/upload-document/route.ts
    import { NextRequest, NextResponse } from 'next/server'
    import { Supermemory } from 'supermemory'

    const client = new Supermemory({
      apiKey: process.env.SUPERMEMORY_API_KEY!
    })

    export async function POST(request: NextRequest) {
      try {
        const formData = await request.formData()
        const file = formData.get('file') as File
        const containerTags = JSON.parse(formData.get('containerTags') as string)
        const metadata = JSON.parse(formData.get('metadata') as string || '{}')

        if (!file) {
          return NextResponse.json({ error: 'कोई फ़ाइल प्रदान नहीं की गई' }, { status: 400 })
        }

        // Supermemory के लिए File को Buffer में convert करें
        const bytes = await file.arrayBuffer()
        const buffer = Buffer.from(bytes)

        const result = await client.memories.uploadFile({
          file: buffer,
          filename: file.name,
          containerTags,
          metadata
        })

        return NextResponse.json({
          success: true,
          documentId: result.id,
          message: 'दस्तावेज़ सफलतापूर्वक upload हो गया'
        })

      } catch (error) {
        console.error('Upload error:', error)
        return NextResponse.json(
          { error: 'Upload असफल', details: error.message },
          { status: 500 }
        )
      }
    }
    ```
  </Tab>

  <Tab title="Python">
    ```python document_processor.py
    from supermemory import Supermemory
    import os
    from typing import Dict, List, Any, Optional
    import requests
    from datetime import datetime

    class DocumentProcessor:
        def __init__(self):
            self.client = Supermemory(api_key=os.getenv("SUPERMEMORY_API_KEY"))

        def upload_file(self, file_path: str, collection: str, metadata: Dict[str, Any] = None) -> Dict:
            """स्थानीय फ़ाइल को Supermemory में अपलोड करें"""
            if metadata is None:
                metadata = {}

            try:
                with open(file_path, 'rb') as file:
                    result = self.client.memories.upload_file(
                        file=file,
                        container_tags=[collection],
                        metadata={
                            'originalName': os.path.basename(file_path),
                            'fileType': os.path.splitext(file_path)[1],
                            'uploadedAt': datetime.now().isoformat(),
                            **metadata
                        }
                    )
                return result
            except Exception as e:
                print(f"फ़ाइल अपलोड त्रुटि: {e}")
                raise

        def upload_url(self, url: str, collection: str, metadata: Dict[str, Any] = None) -> Dict:
            """URL सामग्री को Supermemory में अपलोड करें"""
            if metadata is None:
                metadata = {}

            try:
                result = self.client.memories.add(
                    content=url,
                    container_tag=collection,
                    metadata={
                        'type': 'url',
                        'originalUrl': url,
                        'uploadedAt': datetime.now().isoformat(),
                        **metadata
                    }
                )
                return result
            except Exception as e:
                print(f"URL अपलोड त्रुटि: {e}")
                raise

        def get_document_status(self, document_id: str) -> Dict:
            """document प्रसंस्करण status की जांच करें"""
            try:
                memory = self.client.memories.get(document_id)
                return {
                    'id': memory.id,
                    'status': memory.status,
                    'title': memory.title,
                    'progress': memory.metadata.get('progress', 0) if memory.metadata else 0
                }
            except Exception as e:
                print(f"Status जांच त्रुटि: {e}")
                raise

        def list_documents(self, collection: str) -> List[Dict]:
            """संग्रह में सभी documents की सूची प्राप्त करें"""
            try:
                memories = self.client.memories.list(
                    container_tags=[collection],
                    limit=50,
                    sort='updatedAt',
                    order='desc'
                )

                return [
                    {
                        'id': memory.id,
                        'title': (memory.title or
                                memory.metadata.get('originalName') or
                                'बिना शीर्षक' if memory.metadata else 'बिना शीर्षक'),
                        'type': (memory.metadata.get('fileType') or
                               memory.metadata.get('type') or
                               'अज्ञात' if memory.metadata else 'अज्ञात'),
                        'uploadedAt': memory.metadata.get('uploadedAt') if memory.metadata else None,
                        'status': memory.status,
                        'url': memory.metadata.get('originalUrl') if memory.metadata else None
                    }
                    for memory in memories.memories
                ]
            except Exception as e:
                print(f"Documents सूची त्रुटि: {e}")
                raise
    ```
  </Tab>
</Tabs>

<div id="step-2-qa-api-with-citations">
  ### चरण 2: संदर्भों सहित Q&A API
</div>

<Tabs>
  <Tab title="Next.js API रूट">
    ```typescript app/api/qa/route.ts
    import { streamText } from 'ai'
    import { createOpenAI } from '@ai-sdk/openai'
    import { Supermemory } from 'supermemory'

    const openai = createOpenAI({
      apiKey: process.env.OPENAI_API_KEY!
    })

    const client = new Supermemory({
      apiKey: process.env.SUPERMEMORY_API_KEY!
    })

    export async function POST(request: Request) {
      const { question, collection, conversationHistory = [] } = await request.json()

      try {
        // संबंधित documents खोजें
        const searchResults = await client.search.documents({
          q: question,
          containerTags: [collection],
          limit: 8,
          rerank: true,
          includeFullDocs: false,
          includeSummary: true,
          onlyMatchingChunks: false,
          documentThreshold: 0.6,
          chunkThreshold: 0.7
        })

        if (searchResults.results.length === 0) {
          return Response.json({
            answer: "मैं अपलोड किए गए documents में आपके प्रश्न का उत्तर देने के लिए कोई संबंधित जानकारी नहीं खोज सका।",
            sources: [],
            confidence: 0
          })
        }

        // खोज परिणामों से संदर्भ तैयार करें
        const context = searchResults.results.map((result, index) => {
          const chunks = result.chunks
            .filter(chunk => chunk.isRelevant)
            .slice(0, 3)
            .map(chunk => chunk.content)
            .join('\n\n')

          return `[Document ${index + 1}: "${result.title}"]\n${chunks}`
        }).join('\n\n---\n\n')

        // उद्धरण के लिए स्रोत तैयार करें
        const sources = searchResults.results.map((result, index) => ({
          id: result.documentId,
          title: result.title,
          type: result.type,
          relevantChunks: result.chunks.filter(chunk => chunk.isRelevant).length,
          score: result.score,
          citationNumber: index + 1
        }))

        const messages = [
          ...conversationHistory,
          {
            role: 'user' as const,
            content: question
          }
        ]

        const result = await streamText({
          model: openai('gpt-5'),
          messages,
          system: `आप एक सहायक document Q&A असिस्टेंट हैं। केवल प्रदान किए गए document संदर्भ के आधार पर प्रश्नों का उत्तर दें।

    DOCUMENTS से संदर्भ:
    ${context}

    निर्देश:
    1. केवल प्रदान किए गए documents की जानकारी का उपयोग करके प्रश्न का उत्तर दें
    2. अपने उत्तर में [Document X] फॉर्मेट का उपयोग करके स्पष्ट उद्धरण शामिल करें
    3. यदि documents में पर्याप्त जानकारी नहीं है, तो इसे स्पष्ट रूप से बताएं
    4. सटीक रहें और जब संभव हो तो सीधे उद्धृत करें
    5. यदि कई documents किसी बिंदु का समर्थन करते हैं, तो सभी संबंधित का उद्धरण दें
    6. एक सहायक, व्यावसायिक टोन बनाए रखें

    उद्धरण फॉर्मेट:
    - स्रोतों का उद्धरण देने के लिए [Document 1], [Document 2], आदि का उपयोग करें
    - संबंधित जानकारी के बाद उद्धरण लगाएं
    - उदाहरण: "प्रक्रिया में तीन चरण शामिल हैं [Document 1]। हालांकि, कुछ विशेषज्ञ चार-चरणीय दृष्टिकोण की सिफारिश करते हैं [Document 3]।"

    यदि प्रदान किए गए documents से प्रश्न का उत्तर नहीं दिया जा सकता, तो इस प्रकार उत्तर दें: "मेरे पास इस प्रश्न का सटीक उत्तर देने के लिए प्रदान किए गए documents में पर्याप्त जानकारी नहीं है।"`,
          temperature: 0.1,
          maxTokens: 1000
        })

        return result.toAIStreamResponse({
          data: {
            sources,
            searchResultsCount: searchResults.results.length,
            totalResults: searchResults.total
          }
        })

      } catch (error) {
        console.error('Q&A एरर:', error)
        return Response.json(
          { error: 'प्रश्न प्रोसेस करने में असफल', details: error.message },
          { status: 500 }
        )
      }
    }
    ```
  </Tab>

  <Tab title="Python FastAPI">
    ```python qa_api.py
    from fastapi import FastAPI, HTTPException
    from fastapi.responses import StreamingResponse
    from pydantic import BaseModel
    from typing import List, Dict, Any, Optional
    import openai
    from supermemory import Supermemory
    import json
    import os

    app = FastAPI()

    openai_client = openai.AsyncOpenAI(api_key=os.getenv("OPENAI_API_KEY"))
    supermemory_client = Supermemory(api_key=os.getenv("SUPERMEMORY_API_KEY"))

    class QARequest(BaseModel):
        question: str
        collection: str
        conversationHistory: List[Dict[str, str]] = []

    class QAResponse(BaseModel):
        answer: str
        sources: List[Dict[str, Any]]
        confidence: float
        searchResultsCount: int

    @app.post("/qa")
    async def answer_question(request: QARequest):
        try:
            # संबंधित documents खोजें
            search_results = supermemory_client.search.documents(
                q=request.question,
                container_tags=[request.collection],
                limit=8,
                rerank=True,
                include_full_docs=False,
                include_summary=True,
                only_matching_chunks=False,
                document_threshold=0.6,
                chunk_threshold=0.7
            )

            if not search_results.results:
                return QAResponse(
                    answer="मैं आपके प्रश्न का उत्तर देने के लिए अपलोड किए गए documents में कोई संबंधित जानकारी नहीं खोज सका।",
                    sources=[],
                    confidence=0,
                    searchResultsCount=0
                )

            # खोज परिणामों से context तैयार करें
            context_parts = []
            sources = []

            for index, result in enumerate(search_results.results):
                relevant_chunks = [
                    chunk.content for chunk in result.chunks
                    if chunk.is_relevant
                ][:3]

                chunk_text = '\n\n'.join(relevant_chunks)
                context_parts.append(f'[Document {index + 1}: "{result.title}"]\n{chunk_text}')

                sources.append({
                    'id': result.document_id,
                    'title': result.title,
                    'type': result.type,
                    'relevantChunks': len([c for c in result.chunks if c.is_relevant]),
                    'score': result.score,
                    'citationNumber': index + 1
                })

            context = '\n\n---\n\n'.join(context_parts)

            # messages तैयार करें
            messages = [
                {
                    "role": "system",
                    "content": f"""आप एक सहायक document Q&A असिस्टेंट हैं। केवल प्रदान किए गए document context के आधार पर प्रश्नों का उत्तर दें।

    DOCUMENTS से CONTEXT:
    {context}

    निर्देश:
    1. केवल प्रदान किए गए documents की जानकारी का उपयोग करके प्रश्न का उत्तर दें
    2. अपनी response में [Document X] format का उपयोग करके specific citations शामिल करें
    3. यदि documents में पर्याप्त जानकारी नहीं है, तो इसे स्पष्ट रूप से बताएं
    4. सटीक रहें और जब संभव हो तो सीधे quote करें
    5. यदि कई documents किसी point का समर्थन करते हैं, तो सभी relevant ones को cite करें
    6. एक helpful, professional tone बनाए रखें

    CITATION FORMAT:
    - sources को cite करने के लिए [Document 1], [Document 2], आदि का उपयोग करें
    - relevant information के बाद citations रखें
    - उदाहरण: "प्रक्रिया में तीन steps शामिल हैं [Document 1]। हालांकि, कुछ experts चार-step approach की recommend करते हैं [Document 3]।"

    यदि provided documents से प्रश्न का उत्तर नहीं दिया जा सकता, तो respond करें: "मेरे पास इस प्रश्न का accurately उत्तर देने के लिए provided documents में पर्याप्त जानकारी नहीं है।" """
                }
            ]

            # conversation history जोड़ें
            messages.extend(request.conversationHistory)
            messages.append({"role": "user", "content": request.question})

            # AI response प्राप्त करें
            response = await openai_client.chat.completions.create(
                model="gpt-5",
                messages=messages,
                temperature=0.1,
                max_tokens=1000
            )

            answer = response.choices[0].message.content

            return QAResponse(
                answer=answer,
                sources=sources,
                confidence=min(search_results.results[0].score if search_results.results else 0, 1.0),
                searchResultsCount=len(search_results.results)
            )

        except Exception as e:
            raise HTTPException(status_code=500, detail=f"प्रश्न को process करने में failed: {str(e)}")

    if __name__ == "__main__":
        import uvicorn
        uvicorn.run(app, host="0.0.0.0", port=8000)
    ```
  </Tab>
</Tabs>

<div id="step-3-frontend-interface">
  ### चरण 3: फ्रंटएंड इंटरफेस
</div>

```tsx app/qa/page.tsx
'use client'

import { useState, useRef } from 'react'
import { useChat } from 'ai/react'
import { DocumentProcessor } from '@/lib/document-processor'

interface Document {
  id: string
  title: string
  type: string
  status: string
  uploadedAt: string
}

interface Source {
  id: string
  title: string
  citationNumber: number
  score: number
  relevantChunks: number
}

export default function DocumentQA() {
  const [collection, setCollection] = useState('default-docs')
  const [documents, setDocuments] = useState<Document[]>([])
  const [sources, setSources] = useState<Source[]>([])
  const [isUploading, setIsUploading] = useState(false)
  const [uploadProgress, setUploadProgress] = useState<Record<string, number>>({})
  const fileInputRef = useRef<HTMLInputElement>(null)

  const processor = new DocumentProcessor()

  const { messages, input, handleInputChange, handleSubmit, isLoading } = useChat({
    api: '/api/qa',
    body: {
      collection
    },
    onFinish: (message, { data }) => {
      if (data?.sources) {
        setSources(data.sources)
      }
    }
  })

  const handleFileUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const files = event.target.files
    if (!files || files.length === 0) return

    setIsUploading(true)
    const newProgress: Record<string, number> = {}

    try {
      for (const file of Array.from(files)) {
        newProgress[file.name] = 0
        setUploadProgress({ ...newProgress })

        await processor.uploadDocument({
          file,
          collection,
          metadata: {
            uploadedBy: 'user',
            category: 'qa-document'
          }
        })

        newProgress[file.name] = 100
        setUploadProgress({ ...newProgress })
      }

      // Refresh document list
      await loadDocuments()

      // Clear file input
      if (fileInputRef.current) {
        fileInputRef.current.value = ''
      }

    } catch (error) {
      console.error('Upload failed:', error)
      alert('Upload failed: ' + error.message)
    } finally {
      setIsUploading(false)
      setUploadProgress({})
    }
  }

  const loadDocuments = async () => {
    try {
      const docs = await processor.listDocuments(collection)
      setDocuments(docs)
    } catch (error) {
      console.error('Failed to load documents:', error)
    }
  }

  const formatSources = (sources: Source[]) => {
    if (!sources || sources.length === 0) return null

    return (
      <div className="mt-4 p-4 bg-gray-50 border border-gray-200 rounded-lg">
        <h3 className="text-sm font-semibold text-gray-700 mb-2">स्रोत:</h3>
        <div className="space-y-2">
          {sources.map((source) => (
            <div key={source.id} className="flex items-center space-x-2 text-sm">
              <span className="bg-blue-100 text-blue-800 px-2 py-1 rounded text-xs font-mono">
                Document {source.citationNumber}
              </span>
              <span className="text-gray-700">{source.title}</span>
              <span className="text-gray-500">
                ({source.relevantChunks} संबंधित चंक, {(source.score * 100).toFixed(1)}% मैच)
              </span>
            </div>
          ))}
        </div>
      </div>
    )
  }

  return (
    <div className="max-w-6xl mx-auto p-6">
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* Document Management Panel */}
        <div className="lg:col-span-1">
          <div className="bg-white border border-gray-200 rounded-lg p-6">
            <h2 className="text-lg font-semibold mb-4">Document संग्रह</h2>

            {/* Collection Selector */}
            <div className="mb-4">
              <label className="block text-sm font-medium text-gray-700 mb-2">
                संग्रह का नाम
              </label>
              <input
                type="text"
                value={collection}
                onChange={(e) => setCollection(e.target.value)}
                className="w-full p-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                placeholder="जैसे, company-docs"
              />
            </div>

            {/* File Upload */}
            <div className="mb-4">
              <input
                ref={fileInputRef}
                type="file"
                multiple
                accept=".pdf,.docx,.txt,.md"
                onChange={handleFileUpload}
                className="hidden"
              />
              <button
                onClick={() => fileInputRef.current?.click()}
                disabled={isUploading}
                className="w-full p-3 border-2 border-dashed border-gray-300 rounded-lg hover:border-blue-400 focus:ring-2 focus:ring-blue-500 disabled:opacity-50"
              >
                {isUploading ? 'अपलोड हो रहा है...' : 'Documents अपलोड करें'}
              </button>
            </div>

            {/* Upload Progress */}
            {Object.keys(uploadProgress).length > 0 && (
              <div className="mb-4 space-y-2">
                {Object.entries(uploadProgress).map(([filename, progress]) => (
                  <div key={filename} className="text-sm">
                    <div className="flex justify-between">
                      <span className="truncate">{filename}</span>
                      <span>{progress}%</span>
                    </div>
                    <div className="w-full bg-gray-200 rounded-full h-2">
                      <div
                        className="bg-blue-600 h-2 rounded-full transition-all duration-300"
                        style={{ width: `${progress}%` }}
                      />
                    </div>
                  </div>
                ))}
              </div>
            )}

            {/* Document List */}
            <div className="max-h-64 overflow-y-auto">
              {documents.map((doc) => (
                <div key={doc.id} className="mb-2 p-2 bg-gray-50 rounded text-sm">
                  <div className="font-medium truncate">{doc.title}</div>
                  <div className="text-gray-500 text-xs">
                    {doc.type} • {doc.status}
                  </div>
                </div>
              ))}
            </div>

            <button
              onClick={loadDocuments}
              className="w-full mt-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
            >
              Documents रीफ्रेश करें
            </button>
          </div>
        </div>

        {/* Q&A Interface */}
        <div className="lg:col-span-2">
          <div className="bg-white border border-gray-200 rounded-lg p-6">
            <h2 className="text-lg font-semibold mb-4">प्रश्न पूछें</h2>

            {/* Messages */}
            <div className="h-96 overflow-y-auto mb-4 space-y-4">
              {messages.length === 0 && (
                <div className="text-gray-500 text-center py-8">
                  Documents अपलोड करें और शुरुआत करने के लिए प्रश्न पूछें!

                  <div className="mt-4 text-sm">
                    <p className="font-medium">ये प्रश्न पूछकर देखें:</p>
                    <ul className="mt-2 space-y-1">
                      <li>"मुख्य निष्कर्ष क्या हैं?"</li>
                      <li>"मुख्य बिंदुओं का सारांश दें"</li>
                      <li>"धारा 3 में ... के बारे में क्या कहा गया है?"</li>
                    </ul>
                  </div>
                </div>
              )}

              {messages.map((message) => (
                <div
                  key={message.id}
                  className={`p-4 rounded-lg ${
                    message.role === 'user'
                      ? 'bg-blue-500 text-white ml-8'
                      : 'bg-gray-100 mr-8'
                  }`}
                >
                  <div className="whitespace-pre-wrap">{message.content}</div>

                  {message.role === 'assistant' && sources.length > 0 && (
                    formatSources(sources)
                  )}
                </div>
              ))}

              {isLoading && (
                <div className="bg-gray-100 p-4 rounded-lg mr-8">
                  <div className="flex items-center space-x-2">
                    <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
                    <span>Documents में खोज की जा रही है और उत्तर तैयार किया जा रहा है...</span>
                  </div>
                </div>
              )}
            </div>

            {/* Input */}
            <form onSubmit={handleSubmit} className="flex gap-2">
              <input
                value={input}
                onChange={handleInputChange}
                placeholder="अपने documents के बारे में सवाल पूछें..."
                className="flex-1 p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                disabled={isLoading || documents.length === 0}
              />
              <button
                type="submit"
                disabled={isLoading || !input.trim() || documents.length === 0}
                className="px-6 py-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                पूछें
              </button>
            </form>

            {documents.length === 0 && (
              <p className="text-sm text-gray-500 mt-2">
                सवाल पूछने के लिए पहले documents अपलोड करें
              </p>
            )}
          </div>
        </div>
      </div>
    </div>
  )
}
```

<div id="testing-your-qa-system">
  ## अपने Q&A सिस्टम का परीक्षण करना
</div>

<div id="step-4-test-document-processing">
  ### चरण 4: Document प्रोसेसिंग का परीक्षण
</div>

1. **टेस्ट Documents अपलोड करें**:
   - एक PDF मैनुअल या रिसर्च पेपर अपलोड करें
   - url के माध्यम से कुछ वेब आर्टिकल जोड़ें
   - अलग-अलग विषयों वाली कुछ टेक्स्ट फाइलें अपलोड करें

2. **प्रश्न प्रकारों का परीक्षण करें**:
   ```
   तथ्यात्मक: "Documents में उल्लिखित X की परिभाषा क्या है?"
   विश्लेषणात्मक: "एप्रोच Y के फायदे और नुकसान क्या हैं?"
   तुलनात्मक: "मेथड A की तुलना मेथड B से कैसे होती है?"
   संक्षेपण: "मुख्य निष्कर्षों का सारांश दें"
   ```

3. **उद्धरण सत्यापित करें**:
   - जांचें कि प्रतिक्रियाओं में उद्धरण दिखाई दें
   - सत्यापित करें कि उद्धरण संख्या स्रोत सूची से मेल खाती हो
   - सुनिश्चित करें कि स्रोत प्रासंगिक मेटाडेटा दिखाएं

<div id="production-considerations">
  ## प्रोडक्शन से जुड़ी बातें
</div>

<div id="performance-optimization">
  ### परफॉर्मेंस ऑप्टिमाइज़ेशन
</div>

```typescript
// अक्सर पूछे जाने वाले प्रश्नों के लिए कैशिंग लागू करें
const cacheKey = `qa:${collection}:${hashQuery(question)}`
const cachedResponse = await redis.get(cacheKey)

if (cachedResponse) {
  return JSON.parse(cachedResponse)
}

// 1 घंटे के लिए रिस्पॉन्स को कैश करें
await redis.setex(cacheKey, 3600, JSON.stringify(response))
```


<div id="advanced-features">
  ### उन्नत फीचर्स
</div>

1. **फॉलो‑अप प्रश्न**:
   ```typescript
   // बातचीत के संदर्भ को ट्रैक करें
   const conversationHistory = messages.slice(-6) // पिछली 3 अदला-बदल
   ```

2. **उत्तर भरोसेमंदी स्कोरिंग**:
   ```typescript
   const confidence = calculateConfidence({
     searchScore: searchResults.results[0]?.score || 0,
     resultCount: searchResults.results.length,
     chunkRelevance: avgChunkRelevance
   })
   ```

3. **बहुभाषी समर्थन**:
   ```typescript
   // Documents की भाषा का पता लगाएँ और खोज को अनुकूलित करें
   const detectedLanguage = await detectLanguage(question)
   const searchResults = await client.search.documents({
     q: question,
     filters: {
       AND: [{ key: 'language', value: detectedLanguage }]
     }
   })
   ```

यह रेसिपी सटीक संदर्भों और स्रोत ट्रैकिंग के साथ Documents Q&A सिस्टम बनाने के लिए एक मजबूत आधार प्रदान करती है।

---

*अपने विशिष्ट Documents प्रकारों और उपयोग मामलों के आधार पर इस रेसिपी को कस्टमाइज़ करें।*