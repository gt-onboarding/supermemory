---
title: "संग्रहीत स्मृतियाँ अपडेट करें और हटाएँ"
description: "upsert पैटर्न और idempotency के साथ संग्रहीत स्मृतियों को सुरक्षित रूप से अपडेट और हटाएँ"
icon: "delete"
---

प्रत्यक्ष अपडेट, idempotent upserts, एकल हटाने, और शक्तिशाली बल्क ऑपरेशनों में से चुनें।

<div id="direct-updates">
  ## प्रत्यक्ष अपडेट
</div>

जब आप उस विशिष्ट memory को जानते हैं जिसे आप संशोधित करना चाहते हैं, तो उसकी ID द्वारा मौजूदा संग्रहीत स्मृतियाँ अपडेट करें। बदलाव पूरे पाइपलाइन में पुनर्प्रक्रिया (reprocessing) को ट्रिगर करते हैं।

<CodeGroup>

```typescript Typescript
import Supermemory from 'supermemory';

const client = new Supermemory({
  apiKey: process.env.SUPERMEMORY_API_KEY!
});

// Update by memory ID
const updated = await client.memories.update('memory_id_123', {
  content: 'Updated content here',
  metadata: { version: 2, updated: true }
});

console.log(updated.status); // पुनर्प्रक्रिया के लिए "queued"
console.log(updated.id); // "memory_id_123"
```

```python Python
from supermemory import Supermemory
import os

client = Supermemory(api_key=os.environ.get("SUPERMEMORY_API_KEY"))

# Update by memory ID
updated = client.memories.update(
    'memory_id_123',
    content='Updated content here',
    metadata={'version': 2, 'updated': True}
)

print(f"Status: {updated.status}")  # पुनर्प्रक्रिया के लिए "queued"
print(f"ID: {updated.id}")  # "memory_id_123"
```

```bash cURL
curl -X PATCH "https://api.supermemory.ai/v3/documents/memory_id_123" \
  -H "Authorization: Bearer $SUPERMEMORY_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "content": "Updated content here",
    "metadata": {"version": 2, "updated": true}
  }'
```

</CodeGroup>

<div id="upserts-using-customid">
  ## customId का उपयोग करके Upserts
</div>

Idempotent ऑपरेशनों के लिए `customId` का उपयोग करें, जहाँ वही `customId` के साथ `add()` कॉल करने पर नई कॉपी बनाने के बजाय मौजूदा memory अपडेट हो जाती है।

<CodeGroup>

```typescript Typescript
import Supermemory from 'supermemory';

const client = new Supermemory({
  apiKey: process.env.SUPERMEMORY_API_KEY!
});

const customId = 'user-note-001';

// First call creates memory
const created = await client.memories.add({
  content: 'Initial content',
  customId: customId,
  metadata: { version: 1 }
});

console.log('Created memory:', created.id);

// Second call with same customId updates existing
const updated = await client.memories.add({
  content: 'Updated content',
  customId: customId,         // Same customId = upsert
  metadata: { version: 2 }
});
```

```python Python
from supermemory import Supermemory
import os

client = Supermemory(api_key=os.environ.get("SUPERMEMORY_API_KEY"))

custom_id = 'user-note-001'

# First call creates memory
created = client.memories.add(
    content='Initial content',
    custom_id=custom_id,
    metadata={'version': 1}
)

print(f'Created memory: {created.id}')

# Second call with same customId updates existing
updated = client.memories.add(
    content='Updated content',
    custom_id=custom_id,     # Same customId = upsert
    metadata={'version': 2}
)

print(f'Updated memory: {updated.id}')
print(f'Same memory? {created.id == updated.id}')  # True
```

```bash cURL
# First call - creates memory
curl -X POST "https://api.supermemory.ai/v3/documents" \
  -H "Authorization: Bearer $SUPERMEMORY_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "content": "Initial content",
    "customId": "user-note-001",
    "metadata": {"version": 1}
  }'

# Response: {"id": "mem_abc123", "status": "queued", "customId": "user-note-001"}

# Second call - updates existing (same customId)
curl -X POST "https://api.supermemory.ai/v3/documents" \
  -H "Authorization: Bearer $SUPERMEMORY_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "content": "Updated content",
    "customId": "user-note-001",
    "metadata": {"version": 2}
  }'

# Response: {"id": "mem_abc123", "status": "queued", "customId": "user-note-001"}
# Note: Same ID returned - memory was updated, not created
```

</CodeGroup>

<Note>
`customId` सभी endpoints पर idempotency सक्षम करता है। `memoryId` idempotency सपोर्ट नहीं करता—केवल `customId` करता है।
</Note>

<div id="single-delete">
  ## Single Delete
</div>

ID के आधार पर व्यक्तिगत संग्रहीत स्मृतियाँ हटाएँ। यह स्थायी हार्ड डिलीट है जिसमें पुनर्प्राप्ति का कोई तंत्र नहीं है।

<CodeGroup>

```typescript Typescript
// हार्ड डिलीट - memory को स्थायी रूप से हटाता है
await client.memories.delete('memory_id_123');
console.log('Memory deleted successfully');
```

```python Python
# हार्ड डिलीट - memory को स्थायी रूप से हटाता है
client.memories.delete('memory_id_123')
print('Memory deleted successfully')

# एकल डिलीट के लिए त्रुटि प्रबंधन
try:
    client.memories.delete('memory_id_123')
    print('Delete successful')
except NotFoundError:
    print('Memory not found or already deleted')
except AuthenticationError:
    print('Authentication failed')
except Exception as e:
    print(f'Delete failed: {e}')
```

```bash cURL
curl -X DELETE "https://api.supermemory.ai/v3/documents/memory_id_123" \
  -H "Authorization: Bearer $SUPERMEMORY_API_KEY"

# प्रतिक्रिया: 204 No Content (सफल)
# प्रतिक्रिया: 404 Not Found (memory मौजूद नहीं है)
```

</CodeGroup>

<div id="bulk-delete-by-ids">
  ## IDs द्वारा बल्क डिलीट
</div>

memory IDs की एक array प्रदान करके एक साथ कई संग्रहीत स्मृतियाँ हटाएँ। प्रति अनुरोध अधिकतम 100 IDs।

<CodeGroup>

```typescript Typescript
// memory IDs द्वारा बल्क डिलीट
const result = await client.memories.bulkDelete({
  ids: [
    'memory_id_1',
    'memory_id_2',
    'memory_id_3',
    'non_existent_id'  // यह errors में रिपोर्ट किया जाएगा
  ]
});

console.log('बल्क डिलीट परिणाम:', result);
// आउटपुट: {
//   success: true,
//   deletedCount: 3,
//   errors: [
//     { id: "non_existent_id", error: "Memory not found" }
//   ]
// }
```

```python Python
# memory IDs द्वारा बल्क डिलीट
result = client.memories.bulk_delete(
    ids=[
        'memory_id_1',
        'memory_id_2',
        'memory_id_3',
        'non_existent_id'  # यह errors में रिपोर्ट किया जाएगा
    ]
)

print(f'बल्क डिलीट परिणाम: {result}')
# आउटपुट: {
#   'success': True,
#   'deletedCount': 3,
#   'errors': [
#     {'id': 'non_existent_id', 'error': 'Memory not found'}
#   ]
# }
```

```bash cURL
curl -X DELETE "https://api.supermemory.ai/v3/documents/bulk" \
  -H "Authorization: Bearer $SUPERMEMORY_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "ids": [
      "memory_id_1",
      "memory_id_2",
      "memory_id_3",
      "non_existent_id"
    ]
  }'

# प्रतिक्रिया: {
#   "success": true,
#   "deletedCount": 3,
#   "errors": [
#     {"id": "non_existent_id", "error": "Memory not found"}
#   ]
# }
```

</CodeGroup>

<div id="bulk-delete-by-container-tags">
  ## Container Tags द्वारा Bulk Delete
</div>

विशिष्ट container tags के भीतर सभी memory हटाएँ। यह संपूर्ण प्रोजेक्ट्स या उपयोगकर्ता डेटा साफ़ करने में उपयोगी है।

<CodeGroup>

```typescript Typescript
// विशिष्ट container tags में सभी memory हटाएँ
const result = await client.memories.bulkDelete({
  containerTags: ['user-123', 'project-old', 'archived-content']
});

console.log('टैग्स द्वारा बल्क डिलीट का परिणाम:', result);
// Output: {
//   success: true,
//   deletedCount: 45,
//   containerTags: ["user-123", "project-old", "archived-content"]
// }
```

```python Python
# विशिष्ट container tags में सभी memory हटाएँ
result = client.memories.bulk_delete(
    container_tags=['user-123', 'project-old', 'archived-content']
)

print(f'टैग्स द्वारा बल्क डिलीट का परिणाम: {result}')
# Output: {
#   'success': True,
#   'deletedCount': 45,
//   'containerTags': ['user-123', 'project-old', 'archived-content']
# }
```

```bash cURL
curl -X DELETE "https://api.supermemory.ai/v3/documents/bulk" \
  -H "Authorization: Bearer $SUPERMEMORY_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "containerTags": ["user-123", "project-old", "archived-content"]
  }'

# Response: {
#   "success": true,
#   "deletedCount": 45,
#   "containerTags": ["user-123", "project-old", "archived-content"]
# }
```

</CodeGroup>

<div id="advanced-patterns">
  ## उन्नत पैटर्न्स
</div>

<div id="soft-delete-implementation">
  ### सॉफ्ट डिलीट कार्यान्वयन
</div>

ऐप्लिकेशन में ऑडिट ट्रेल या रिकवरी मैकेनिज़्म की आवश्यकता होने पर, Metadata का उपयोग करके सॉफ्ट डिलीट पैटर्न लागू करें:

<CodeGroup>

```typescript Typescript
// Metadata का उपयोग करके सॉफ्ट डिलीट पैटर्न
await client.memories.update('memory_id', {
  metadata: {
    deleted: true,
    deletedAt: new Date().toISOString(),
    deletedBy: 'user_123'
  }
});

// खोज में डिलीट की गई संग्रहीत स्मृतियों को फ़िल्टर करें
const activeMemories = await client.memories.list({
  filters: JSON.stringify({
    AND: [
      { key: "deleted", value: "true", negate: true }
    ]
  })
});

console.log('सक्रिय संग्रहीत स्मृतियाँ:', activeMemories.results.length);
```

```python Python
from datetime import datetime
import json

# Metadata का उपयोग करके सॉफ्ट डिलीट पैटर्न
client.memories.update('memory_id', {
    'metadata': {
        'deleted': True,
        'deletedAt': datetime.now().isoformat(),
        'deletedBy': 'user_123'
    }
})

# डिलीट की गई संग्रहीत स्मृतियों को फ़िल्टर करें
active_memories = client.memories.list(
    filters=json.dumps({
        "AND": [
            {"key": "deleted", "value": "true", "negate": True}
        ]
    })
)

print(f'सक्रिय संग्रहीत स्मृतियाँ: {len(active_memories.results)}')
```

```bash cURL
# Metadata का उपयोग करके सॉफ्ट डिलीट
curl -X PATCH "https://api.supermemory.ai/v3/documents/memory_id" \
  -H "Authorization: Bearer $SUPERMEMORY_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "metadata": {
      "deleted": true,
      "deletedAt": "2024-01-15T10:30:00Z",
      "deletedBy": "user_123"
    }
  }'

# Response: {"id": "memory_id", "status": "queued"}
```

</CodeGroup>

<div id="batch-processing-for-large-operations">
  ### बड़े ऑपरेशनों के लिए बैच प्रोसेसिंग
</div>

<CodeGroup>

```typescript Typescript
// बड़ी संख्या में memory को सुरक्षित रूप से बैच में डिलीट करें
async function batchDeleteMemories(memoryIds: string[], batchSize = 100) {
  const results = [];

  for (let i = 0; i < memoryIds.length; i += batchSize) {
    const batch = memoryIds.slice(i, i + batchSize);

    console.log(`बैच प्रोसेस हो रहा है: ${Math.floor(i/batchSize) + 1} में से ${Math.ceil(memoryIds.length/batchSize)}`);

    try {
      const result = await client.memories.bulkDelete({ ids: batch });
      results.push(result);

      // रेट लिमिटिंग से बचने के लिए बैचों के बीच थोड़ी देरी रखें
      if (i + batchSize < memoryIds.length) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    } catch (error) {
      console.error(`बैच ${Math.floor(i/batchSize) + 1} विफल रहा:`, error);
      results.push({ success: false, error: error.message, batch });
    }
  }

  // परिणाम समेकित करें
  const totalDeleted = results
    .filter(r => r.success)
    .reduce((sum, r) => sum + (r.deletedCount || 0), 0);

  console.log(`कुल डिलीट: ${totalDeleted} / ${memoryIds.length}`);
  return { totalDeleted, results };
}
```

```python Python
import time
import math

def batch_delete_memories(memory_ids, batch_size=100):
    """बड़ी संख्या में memory को सुरक्षित रूप से बैच में डिलीट करें"""
    results = []

    for i in range(0, len(memory_ids), batch_size):
        batch = memory_ids[i:i + batch_size]
        batch_num = i // batch_size + 1
        total_batches = math.ceil(len(memory_ids) / batch_size)

        print(f'बैच प्रोसेस हो रहा है: {batch_num} में से {total_batches}')

        try:
            result = client.memories.bulk_delete(ids=batch)
            results.append(result)

            # रेट लिमिटिंग से बचने के लिए बैचों के बीच थोड़ी देरी रखें
            if i + batch_size < len(memory_ids):
                time.sleep(1)
        except Exception as error:
            print(f'बैच {batch_num} विफल रहा: {error}')
            results.append({'success': False, 'error': str(error), 'batch': batch})

    # परिणाम समेकित करें
    total_deleted = sum(
        r.get('deletedCount', 0) for r in results if r.get('success')
    )

    print(f'कुल डिलीट: {total_deleted} / {len(memory_ids)}')
    return {'totalDeleted': total_deleted, 'results': results}
```

```bash cURL
# बैच प्रोसेसिंग स्क्रिप्ट का उदाहरण
#!/bin/bash

MEMORY_IDS=("id1" "id2" "id3")  # आपकी memory IDs की array
BATCH_SIZE=100
TOTAL_DELETED=0

# बैच में प्रोसेस करें
for ((i=0; i<${#MEMORY_IDS[@]}; i+=BATCH_SIZE)); do
    batch=("${MEMORY_IDS[@]:i:BATCH_SIZE}")
    batch_json=$(printf '%s\n' "${batch[@]}" | jq -R . | jq -s .)

    echo "बैच प्रोसेस हो रहा है: $((i/BATCH_SIZE + 1))"

    response=$(curl -s -X DELETE \
      "https://api.supermemory.ai/v3/documents/bulk" \
      -H "Authorization: Bearer $SUPERMEMORY_API_KEY" \
      -H "Content-Type: application/json" \
      -d "{\"ids\": $batch_json}")

    deleted_count=$(echo "$response" | jq -r '.deletedCount // 0')
    TOTAL_DELETED=$((TOTAL_DELETED + deleted_count))

    echo "बैच में डिलीट: $deleted_count memories"
    sleep 1  # रेट लिमिटिंग सुरक्षा
done

echo "कुल डिलीट: $TOTAL_DELETED memories"
```

</CodeGroup>

<div id="best-practices">
  ## श्रेष्ठ अभ्यास
</div>

<div id="update-operations">
  ### अपडेट ऑपरेशंस
</div>

1. **इडेमेंटन्ट अपडेट्स के लिए customId का उपयोग करें** - डुप्लीकेट संग्रहीत स्मृतियाँ रोकता है और सुरक्षित रिट्राइज़ सक्षम करता है
2. **प्रोसेसिंग status मॉनिटर करें** - अपडेट्स पूरी रीप्रोसेसिंग पाइपलाइन ट्रिगर करते हैं
3. **Metadata को सावधानी से हैंडल करें** - अपडेट्स निर्दिष्ट Metadata keys को प्रतिस्थापित करते हैं
4. **उचित एरर हैंडलिंग लागू करें** - ऑपरेशंस के बीच memory हटाई जा सकती है

<div id="delete-operations">
  ### Delete Operations
</div>

1. **हार्ड डिलीट स्थायी है** - कोई रिकवरी तंत्र उपलब्ध नहीं है
2. **बल्क ऑपरेशंस का प्रभावी उपयोग करें** - प्रत्येक बल्क डिलीट रिक्वेस्ट में अधिकतम 100 IDs
3. **सॉफ्ट डिलीट पैटर्न पर विचार करें** - रिकवर करने योग्य डिलीशन के लिए Metadata फ्लैग्स का उपयोग करें
4. **बड़े ऑपरेशंस को बैच करें** - उचित बैचिंग के साथ रेट लिमिटिंग से बचें
5. **एप्लिकेशन स्टेट को क्लीन अप करें** - डिलीट के बाद अपने UI/कैश को अपडेट करें