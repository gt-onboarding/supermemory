---
title: "Dokumenten-Q&A-System"
description: "Erstelle einen Chatbot, der Fragen zu deinen documents mit Zitaten und Quellenangaben beantwortet"
---

Erstelle ein leistungsstarkes Dokumenten‑Q&A‑System, das PDFs, Textdateien und Webseiten verarbeiten kann und anschließend Fragen mit präzisen Zitaten und Quellenangaben beantwortet. Ideal für Dokumentationsseiten, Forschungsdatenbanken oder interne Wissensbasen.

<div id="what-youll-build">
  ## Was Sie erstellen werden
</div>

Ein Dokumenten‑Q&A‑System, das:

- **Mehrere Dateitypen verarbeitet** (PDFs, DOCX, Text, URLs)
- **Fragen präzise beantwortet** mit Quellenangaben
- **Quellenverweise liefert** mit Seitenzahlen und Dokumenttiteln
- **Rückfragen im Gesprächskontext verarbeitet**
- **Mehrere Dokumentensammlungen für unterschiedliche Themen unterstützt**

<div id="prerequisites">
  ## Voraussetzungen
</div>

- Node.js 18+ oder Python 3.8+
- Supermemory API-Schlüssel
- OpenAI API-Schlüssel
- Grundlegendes Verständnis der Dateiverarbeitung

<div id="implementation">
  ## Implementierung
</div>

<div id="step-1-document-processing-system">
  ### Schritt 1: System zur Dokumentverarbeitung
</div>

<Tabs>
  <Tab title="Next.js">
    ```typescript lib/document-processor.ts
    import { Supermemory } from 'supermemory'

    const client = new Supermemory({
      apiKey: process.env.SUPERMEMORY_API_KEY!
    })

    interface DocumentUpload {
      file: File
      collection: string
      metadata?: Record<string, any>
    }

    export class DocumentProcessor {
      async uploadDocument({ file, collection, metadata = {} }: DocumentUpload) {
        try {
          const formData = new FormData()
          formData.append('file', file)
          formData.append('containerTags', JSON.stringify([collection]))
          formData.append('metadata', JSON.stringify({
            originalName: file.name,
            fileType: file.type,
            uploadedAt: new Date().toISOString(),
            ...metadata
          }))

          const response = await fetch('/api/upload-document', {
            method: 'POST',
            body: formData
          })

          if (!response.ok) {
            throw new Error(`Upload fehlgeschlagen: ${response.statusText}`)
          }

          return await response.json()
        } catch (error) {
          console.error('Fehler beim Dokument-Upload:', error)
          throw error
        }
      }

      async uploadURL({ url, collection, metadata = {} }: { url: string, collection: string, metadata?: Record<string, any> }) {
        try {
          const result = await client.memories.add({
            content: url,
            containerTag: collection,
            metadata: {
              type: 'url',
              originalUrl: url,
              uploadedAt: new Date().toISOString(),
              ...metadata
            }
          })

          return result
        } catch (error) {
          console.error('Fehler beim URL-Upload:', error)
          throw error
        }
      }

      async getDocumentStatus(documentId: string) {
        try {
          const memory = await client.memories.get(documentId)
          return {
            id: memory.id,
            status: memory.status,
            title: memory.title,
            progress: memory.metadata?.progress || 0
          }
        } catch (error) {
          console.error('Fehler bei der Statusabfrage:', error)
          throw error
        }
      }

      async listDocuments(collection: string) {
        try {
          const memories = await client.memories.list({
            containerTags: [collection],
            limit: 50,
            sort: 'updatedAt',
            order: 'desc'
          })

          return memories.memories.map(memory => ({
            id: memory.id,
            title: memory.title || memory.metadata?.originalName || 'Ohne Titel',
            type: memory.metadata?.fileType || memory.metadata?.type || 'unbekannt',
            uploadedAt: memory.metadata?.uploadedAt,
            status: memory.status,
            url: memory.metadata?.originalUrl
          }))
        } catch (error) {
          console.error('Fehler beim Auflisten der Dokumente:', error)
          throw error
        }
      }
    }
    ```

    ```typescript app/api/upload-document/route.ts
    import { NextRequest, NextResponse } from 'next/server'
    import { Supermemory } from 'supermemory'

    const client = new Supermemory({
      apiKey: process.env.SUPERMEMORY_API_KEY!
    })

    export async function POST(request: NextRequest) {
      try {
        const formData = await request.formData()
        const file = formData.get('file') as File
        const containerTags = JSON.parse(formData.get('containerTags') as string)
        const metadata = JSON.parse(formData.get('metadata') as string || '{}')

        if (!file) {
          return NextResponse.json({ error: 'Keine Datei bereitgestellt' }, { status: 400 })
        }

        // Datei in Buffer für Supermemory konvertieren
        const bytes = await file.arrayBuffer()
        const buffer = Buffer.from(bytes)

        const result = await client.memories.uploadFile({
          file: buffer,
          filename: file.name,
          containerTags,
          metadata
        })

        return NextResponse.json({
          success: true,
          documentId: result.id,
          message: 'Dokument erfolgreich hochgeladen'
        })

      } catch (error) {
        console.error('Upload-Fehler:', error)
        return NextResponse.json(
          { error: 'Upload fehlgeschlagen', details: error.message },
          { status: 500 }
        )
      }
    }
    ```
  </Tab>

  <Tab title="Python">
    ```python document_processor.py
    from supermemory import Supermemory
    import os
    from typing import Dict, List, Any, Optional
    import requests
    from datetime import datetime

    class DocumentProcessor:
        def __init__(self):
            self.client = Supermemory(api_key=os.getenv("SUPERMEMORY_API_KEY"))

        def upload_file(self, file_path: str, collection: str, metadata: Dict[str, Any] = None) -> Dict:
            """Lokale Datei zu Supermemory hochladen"""
            if metadata is None:
                metadata = {}

            try:
                with open(file_path, 'rb') as file:
                    result = self.client.memories.upload_file(
                        file=file,
                        container_tags=[collection],
                        metadata={
                            'originalName': os.path.basename(file_path),
                            'fileType': os.path.splitext(file_path)[1],
                            'uploadedAt': datetime.now().isoformat(),
                            **metadata
                        }
                    )
                return result
            except Exception as e:
                print(f"Fehler beim Datei-Upload: {e}")
                raise

        def upload_url(self, url: str, collection: str, metadata: Dict[str, Any] = None) -> Dict:
            """URL-Inhalt zu Supermemory hochladen"""
            if metadata is None:
                metadata = {}

            try:
                result = self.client.memories.add(
                    content=url,
                    container_tag=collection,
                    metadata={
                        'type': 'url',
                        'originalUrl': url,
                        'uploadedAt': datetime.now().isoformat(),
                        **metadata
                    }
                )
                return result
            except Exception as e:
                print(f"Fehler beim URL-Upload: {e}")
                raise

        def get_document_status(self, document_id: str) -> Dict:
            """Status der Dokumentverarbeitung prüfen"""
            try:
                memory = self.client.memories.get(document_id)
                return {
                    'id': memory.id,
                    'status': memory.status,
                    'title': memory.title,
                    'progress': memory.metadata.get('progress', 0) if memory.metadata else 0
                }
            except Exception as e:
                print(f"Fehler bei Statusprüfung: {e}")
                raise

        def list_documents(self, collection: str) -> List[Dict]:
            """Alle Dokumente in einer Sammlung auflisten"""
            try:
                memories = self.client.memories.list(
                    container_tags=[collection],
                    limit=50,
                    sort='updatedAt',
                    order='desc'
                )

                return [
                    {
                        'id': memory.id,
                        'title': (memory.title or
                                memory.metadata.get('originalName') or
                                'Ohne Titel' if memory.metadata else 'Ohne Titel'),
                        'type': (memory.metadata.get('fileType') or
                               memory.metadata.get('type') or
                               'unbekannt' if memory.metadata else 'unbekannt'),
                        'uploadedAt': memory.metadata.get('uploadedAt') if memory.metadata else None,
                        'status': memory.status,
                        'url': memory.metadata.get('originalUrl') if memory.metadata else None
                    }
                    for memory in memories.memories
                ]
            except Exception as e:
                print(f"Fehler beim Auflisten der Dokumente: {e}")
                raise
    ```
  </Tab>
</Tabs>

<div id="step-2-qa-api-with-citations">
  ### Schritt 2: Q&A-API mit Quellenangaben
</div>

<Tabs>
  <Tab title="Next.js-API-Route">
    ```typescript app/api/qa/route.ts
    import { streamText } from 'ai'
    import { createOpenAI } from '@ai-sdk/openai'
    import { Supermemory } from 'supermemory'

    const openai = createOpenAI({
      apiKey: process.env.OPENAI_API_KEY!
    })

    const client = new Supermemory({
      apiKey: process.env.SUPERMEMORY_API_KEY!
    })

    export async function POST(request: Request) {
      const { question, collection, conversationHistory = [] } = await request.json()

      try {
        // Suche nach relevanten Dokumenten
        const searchResults = await client.search.documents({
          q: question,
          containerTags: [collection],
          limit: 8,
          rerank: true,
          includeFullDocs: false,
          includeSummary: true,
          onlyMatchingChunks: false,
          documentThreshold: 0.6,
          chunkThreshold: 0.7
        })

        if (searchResults.results.length === 0) {
          return Response.json({
            answer: „Ich konnte keine relevanten Informationen in den hochgeladenen Dokumenten finden, um Ihre Frage zu beantworten.",
            sources: [],
            confidence: 0
          })
        }

        // Kontext aus Suchergebnissen vorbereiten
        const context = searchResults.results.map((result, index) => {
          const chunks = result.chunks
            .filter(chunk => chunk.isRelevant)
            .slice(0, 3)
            .map(chunk => chunk.content)
            .join('\n\n')

          return `[Dokument ${index + 1}: „${result.title}"]\n${chunks}`
        }).join('\n\n---\n\n')

        // Quellen für Zitierung vorbereiten
        const sources = searchResults.results.map((result, index) => ({
          id: result.documentId,
          title: result.title,
          type: result.type,
          relevantChunks: result.chunks.filter(chunk => chunk.isRelevant).length,
          score: result.score,
          citationNumber: index + 1
        }))

        const messages = [
          ...conversationHistory,
          {
            role: 'user' as const,
            content: question
          }
        ]

        const result = await streamText({
          model: openai('gpt-5'),
          messages,
          system: `Sie sind ein hilfreicher Dokument-Q&A-Assistent. Beantworten Sie Fragen AUSSCHLIEßLICH basierend auf dem bereitgestellten Dokumentkontext.

    KONTEXT AUS DOKUMENTEN:
    ${context}

    ANWEISUNGEN:
    1. Beantworten Sie die Frage AUSSCHLIEßLICH mit Informationen aus den bereitgestellten Dokumenten
    2. Fügen Sie spezifische Quellenangaben in Ihrer Antwort im Format [Dokument X] ein
    3. Wenn die Dokumente nicht genügend Informationen enthalten, sagen Sie das deutlich
    4. Seien Sie präzise und zitieren Sie wörtlich, wenn möglich
    5. Wenn mehrere Dokumente einen Punkt stützen, zitieren Sie alle relevanten
    6. Bewahren Sie einen hilfreichen, professionellen Ton

    ZITIERUNGSFORMAT:
    - Verwenden Sie [Dokument 1], [Dokument 2], usw., um Quellen zu zitieren
    - Platzieren Sie Quellenangaben nach den relevanten Informationen
    - Beispiel: „Der Prozess umfasst drei Schritte [Dokument 1]. Einige Experten empfehlen jedoch einen vierstufigen Ansatz [Dokument 3]."

    Wenn die Frage nicht aus den bereitgestellten Dokumenten beantwortet werden kann, antworten Sie mit: „Ich habe nicht genügend Informationen in den bereitgestellten Dokumenten, um diese Frage präzise zu beantworten."`,
          temperature: 0.1,
          maxTokens: 1000
        })

        return result.toAIStreamResponse({
          data: {
            sources,
            searchResultsCount: searchResults.results.length,
            totalResults: searchResults.total
          }
        })

      } catch (error) {
        console.error('Q&A-Fehler:', error)
        return Response.json(
          { error: 'Verarbeitung der Frage fehlgeschlagen', details: error.message },
          { status: 500 }
        )
      }
    }
    ```
  </Tab>

  <Tab title="Python FastAPI">
    ```python qa_api.py
    from fastapi import FastAPI, HTTPException
    from fastapi.responses import StreamingResponse
    from pydantic import BaseModel
    from typing import List, Dict, Any, Optional
    import openai
    from supermemory import Supermemory
    import json
    import os

    app = FastAPI()

    openai_client = openai.AsyncOpenAI(api_key=os.getenv("OPENAI_API_KEY"))
    supermemory_client = Supermemory(api_key=os.getenv("SUPERMEMORY_API_KEY"))

    class QARequest(BaseModel):
        question: str
        collection: str
        conversationHistory: List[Dict[str, str]] = []

    class QAResponse(BaseModel):
        answer: str
        sources: List[Dict[str, Any]]
        confidence: float
        searchResultsCount: int

    @app.post("/qa")
    async def answer_question(request: QARequest):
        try:
            # Nach relevanten documents suchen
            search_results = supermemory_client.search.documents(
                q=request.question,
                container_tags=[request.collection],
                limit=8,
                rerank=True,
                include_full_docs=False,
                include_summary=True,
                only_matching_chunks=False,
                document_threshold=0.6,
                chunk_threshold=0.7
            )

            if not search_results.results:
                return QAResponse(
                    answer="Ich konnte keine relevanten Informationen in den hochgeladenen documents finden, um Ihre Frage zu beantworten.",
                    sources=[],
                    confidence=0,
                    searchResultsCount=0
                )

            # Kontext aus Suchergebnissen vorbereiten
            context_parts = []
            sources = []

            for index, result in enumerate(search_results.results):
                relevant_chunks = [
                    chunk.content for chunk in result.chunks
                    if chunk.is_relevant
                ][:3]

                chunk_text = '\n\n'.join(relevant_chunks)
                context_parts.append(f'[Document {index + 1}: "{result.title}"]\n{chunk_text}')

                sources.append({
                    'id': result.document_id,
                    'title': result.title,
                    'type': result.type,
                    'relevantChunks': len([c for c in result.chunks if c.is_relevant]),
                    'score': result.score,
                    'citationNumber': index + 1
                })

            context = '\n\n---\n\n'.join(context_parts)

            # Nachrichten vorbereiten
            messages = [
                {
                    "role": "system",
                    "content": f"""Sie sind ein hilfreicher Q&A-Assistent für documents. Beantworten Sie Fragen ausschließlich basierend auf dem bereitgestellten Kontext der documents.

    KONTEXT AUS DOCUMENTS:
    {context}

    ANWEISUNGEN:
    1. Beantworten Sie die Frage ausschließlich mit Informationen aus den bereitgestellten documents
    2. Fügen Sie spezifische Quellenangaben in Ihre Antwort ein, verwenden Sie das Format [Document X]
    3. Wenn die documents nicht genügend Informationen enthalten, sagen Sie das deutlich
    4. Seien Sie präzise und zitieren Sie direkt, wenn möglich
    5. Wenn mehrere documents einen Punkt stützen, zitieren Sie alle relevanten
    6. Bewahren Sie einen hilfreichen, professionellen Ton

    ZITIERFORMAT:
    - Verwenden Sie [Document 1], [Document 2], usw. um Quellen zu zitieren
    - Platzieren Sie Zitate nach den relevanten Informationen
    - Beispiel: „Der Prozess umfasst drei Schritte [Document 1]. Einige Experten empfehlen jedoch einen vierstufigen Ansatz [Document 3]."

    Falls die Frage nicht aus den bereitgestellten documents beantwortet werden kann, antworten Sie mit: „Ich habe nicht genügend Informationen in den bereitgestellten documents, um diese Frage präzise zu beantworten." """
                }
            ]

            # Gesprächsverlauf hinzufügen
            messages.extend(request.conversationHistory)
            messages.append({"role": "user", "content": request.question})

            # AI-Antwort abrufen
            response = await openai_client.chat.completions.create(
                model="gpt-5",
                messages=messages,
                temperature=0.1,
                max_tokens=1000
            )

            answer = response.choices[0].message.content

            return QAResponse(
                answer=answer,
                sources=sources,
                confidence=min(search_results.results[0].score if search_results.results else 0, 1.0),
                searchResultsCount=len(search_results.results)
            )

        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Fehler beim Verarbeiten der Frage: {str(e)}")

    if __name__ == "__main__":
        import uvicorn
        uvicorn.run(app, host="0.0.0.0", port=8000)
    ```
  </Tab>
</Tabs>

<div id="step-3-frontend-interface">
  ### Schritt 3: Frontend
</div>

```tsx app/qa/page.tsx
'use client'

import { useState, useRef } from 'react'
import { useChat } from 'ai/react'
import { DocumentProcessor } from '@/lib/document-processor'

interface Document {
  id: string
  title: string
  type: string
  status: string
  uploadedAt: string
}

interface Source {
  id: string
  title: string
  citationNumber: number
  score: number
  relevantChunks: number
}

export default function DocumentQA() {
  const [collection, setCollection] = useState('default-docs')
  const [documents, setDocuments] = useState<Document[]>([])
  const [sources, setSources] = useState<Source[]>([])
  const [isUploading, setIsUploading] = useState(false)
  const [uploadProgress, setUploadProgress] = useState<Record<string, number>>({})
  const fileInputRef = useRef<HTMLInputElement>(null)

  const processor = new DocumentProcessor()

  const { messages, input, handleInputChange, handleSubmit, isLoading } = useChat({
    api: '/api/qa',
    body: {
      collection
    },
    onFinish: (message, { data }) => {
      if (data?.sources) {
        setSources(data.sources)
      }
    }
  })

  const handleFileUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const files = event.target.files
    if (!files || files.length === 0) return

    setIsUploading(true)
    const newProgress: Record<string, number> = {}

    try {
      for (const file of Array.from(files)) {
        newProgress[file.name] = 0
        setUploadProgress({ ...newProgress })

        await processor.uploadDocument({
          file,
          collection,
          metadata: {
            uploadedBy: 'user',
            category: 'qa-document'
          }
        })

        newProgress[file.name] = 100
        setUploadProgress({ ...newProgress })
      }

      // Refresh document list
      await loadDocuments()

      // Clear file input
      if (fileInputRef.current) {
        fileInputRef.current.value = ''
      }

    } catch (error) {
      console.error('Upload failed:', error)
      alert('Upload failed: ' + error.message)
    } finally {
      setIsUploading(false)
      setUploadProgress({})
    }
  }

  const loadDocuments = async () => {
    try {
      const docs = await processor.listDocuments(collection)
      setDocuments(docs)
    } catch (error) {
      console.error('Failed to load documents:', error)
    }
  }

  const formatSources = (sources: Source[]) => {
    if (!sources || sources.length === 0) return null

    return (
      <div className="mt-4 p-4 bg-gray-50 border border-gray-200 rounded-lg">
        <h3 className="text-sm font-semibold text-gray-700 mb-2">Quellen:</h3>
        <div className="space-y-2">
          {sources.map((source) => (
            <div key={source.id} className="flex items-center space-x-2 text-sm">
              <span className="bg-blue-100 text-blue-800 px-2 py-1 rounded text-xs font-mono">
                Dokument {source.citationNumber}
              </span>
              <span className="text-gray-700">{source.title}</span>
              <span className="text-gray-500">
                ({source.relevantChunks} relevante Chunks, {(source.score * 100).toFixed(1)}% Übereinstimmung)
              </span>
            </div>
          ))}
        </div>
      </div>
    )
  }

  return (
    <div className="max-w-6xl mx-auto p-6">
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* Document Management Panel */}
        <div className="lg:col-span-1">
          <div className="bg-white border border-gray-200 rounded-lg p-6">
            <h2 className="text-lg font-semibold mb-4">Dokumentensammlung</h2>

            {/* Collection Selector */}
            <div className="mb-4">
              <label className="block text-sm font-medium text-gray-700 mb-2">
                Sammlungsname
              </label>
              <input
                type="text"
                value={collection}
                onChange={(e) => setCollection(e.target.value)}
                className="w-full p-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                placeholder="z.B. firmen-docs"
              />
            </div>

            {/* File Upload */}
            <div className="mb-4">
              <input
                ref={fileInputRef}
                type="file"
                multiple
                accept=".pdf,.docx,.txt,.md"
                onChange={handleFileUpload}
                className="hidden"
              />
              <button
                onClick={() => fileInputRef.current?.click()}
                disabled={isUploading}
                className="w-full p-3 border-2 border-dashed border-gray-300 rounded-lg hover:border-blue-400 focus:ring-2 focus:ring-blue-500 disabled:opacity-50"
              >
                {isUploading ? 'Wird hochgeladen...' : 'Dokumente hochladen'}
              </button>
            </div>

            {/* Upload Progress */}
            {Object.keys(uploadProgress).length > 0 && (
              <div className="mb-4 space-y-2">
                {Object.entries(uploadProgress).map(([filename, progress]) => (
                  <div key={filename} className="text-sm">
                    <div className="flex justify-between">
                      <span className="truncate">{filename}</span>
                      <span>{progress}%</span>
                    </div>
                    <div className="w-full bg-gray-200 rounded-full h-2">
                      <div
                        className="bg-blue-600 h-2 rounded-full transition-all duration-300"
                        style={{ width: `${progress}%` }}
                      />
                    </div>
                  </div>
                ))}
              </div>
            )}

            {/* Document List */}
            <div className="max-h-64 overflow-y-auto">
              {documents.map((doc) => (
                <div key={doc.id} className="mb-2 p-2 bg-gray-50 rounded text-sm">
                  <div className="font-medium truncate">{doc.title}</div>
                  <div className="text-gray-500 text-xs">
                    {doc.type} • {doc.status}
                  </div>
                </div>
              ))}
            </div>

            <button
              onClick={loadDocuments}
              className="w-full mt-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
            >
              Dokumente aktualisieren
            </button>
          </div>
        </div>

        {/* Q&A Interface */}
        <div className="lg:col-span-2">
          <div className="bg-white border border-gray-200 rounded-lg p-6">
            <h2 className="text-lg font-semibold mb-4">Fragen stellen</h2>

            {/* Messages */}
            <div className="h-96 overflow-y-auto mb-4 space-y-4">
              {messages.length === 0 && (
                <div className="text-gray-500 text-center py-8">
                  Laden Sie Dokumente hoch und stellen Sie Fragen, um zu beginnen!

                  <div className="mt-4 text-sm">
                    <p className="font-medium">Beispielfragen:</p>
                    <ul className="mt-2 space-y-1">
                      <li>„Was sind die wichtigsten Erkenntnisse?"</li>
                      <li>„Fassen Sie die Kernpunkte zusammen"</li>
                      <li>„Was sagt Abschnitt 3 über...?"</li>
                    </ul>
                  </div>
                </div>
              )}

              {messages.map((message) => (
                <div
                  key={message.id}
                  className={`p-4 rounded-lg ${
                    message.role === 'user'
                      ? 'bg-blue-500 text-white ml-8'
                      : 'bg-gray-100 mr-8'
                  }`}
                >
                  <div className="whitespace-pre-wrap">{message.content}</div>

                  {message.role === 'assistant' && sources.length > 0 && (
                    formatSources(sources)
                  )}
                </div>
              ))}

              {isLoading && (
                <div className="bg-gray-100 p-4 rounded-lg mr-8">
                  <div className="flex items-center space-x-2">
                    <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
                    <span>Durchsuche Dokumente und erstelle Antwort...</span>
                  </div>
                </div>
              )}
            </div>

            {/* Input */}
            <form onSubmit={handleSubmit} className="flex gap-2">
              <input
                value={input}
                onChange={handleInputChange}
                placeholder="Stellen Sie eine Frage zu Ihren Dokumenten..."
                className="flex-1 p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                disabled={isLoading || documents.length === 0}
              />
              <button
                type="submit"
                disabled={isLoading || !input.trim() || documents.length === 0}
                className="px-6 py-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                Fragen
              </button>
            </form>

            {documents.length === 0 && (
              <p className="text-sm text-gray-500 mt-2">
                Laden Sie zuerst Dokumente hoch, um Fragen zu ermöglichen
              </p>
            )}
          </div>
        </div>
      </div>
    </div>
  )
}
```

<div id="testing-your-qa-system">
  ## Testen Ihres Q&A-Systems
</div>

<div id="step-4-test-document-processing">
  ### Schritt 4: Dokumentenverarbeitung testen
</div>

1. **Testdokumente hochladen**:
   - Ein PDF-Handbuch oder einen Forschungsartikel hochladen
   - Einige Webartikel per url hinzufügen
   - Einige Textdateien mit unterschiedlichen Themen hochladen

2. **Fragetypen testen**:
   ```
   Sachlich: „Was ist die Definition von X, die in den documents erwähnt wird?“
   Analytisch: „Was sind die Vor- und Nachteile von Ansatz Y?“
   Vergleichend: „Wie schneidet Methode A im Vergleich zu Methode B ab?“
   Zusammenfassung: „Fasse die wichtigsten Erkenntnisse zusammen“
   ```

3. **Zitate überprüfen**:
   - Prüfen, ob Zitate in den Antworten erscheinen
   - Überprüfen, ob Zitiernummern mit der Quellliste übereinstimmen
   - Sicherstellen, dass Quellen relevante Metadata anzeigen

<div id="production-considerations">
  ## Aspekte für den Produktionseinsatz
</div>

<div id="performance-optimization">
  ### Performanceoptimierung
</div>

```typescript
// Caching für häufig gestellte Fragen implementieren
const cacheKey = `qa:${collection}:${hashQuery(question)}`
const cachedResponse = await redis.get(cacheKey)

if (cachedResponse) {
  return JSON.parse(cachedResponse)
}

// Antwort für 1 Stunde zwischenspeichern
await redis.setex(cacheKey, 3600, JSON.stringify(response))
```


<div id="advanced-features">
  ### Erweiterte Funktionen
</div>

1. **Nachfragen**:
   ```typescript
   // Gesprächskontext nachverfolgen
   const conversationHistory = messages.slice(-6) // Letzte 3 Austauschrunden
   ```

2. **Bewertung der Antwortsicherheit**:
   ```typescript
   const confidence = calculateConfidence({
     searchScore: searchResults.results[0]?.score || 0,
     resultCount: searchResults.results.length,
     chunkRelevance: avgChunkRelevance
   })
   ```

3. **Mehrsprachige Unterstützung**:
   ```typescript
   // Dokumentensprache erkennen und Suche anpassen
   const detectedLanguage = await detectLanguage(question)
   const searchResults = await client.search.documents({
     q: question,
     filters: {
       AND: [{ key: 'language', value: detectedLanguage }]
     }
   })
   ```

Dieses Rezept bietet eine solide Grundlage für den Aufbau von Q&A-Systemen über documents mit präzisen Zitaten und Nachvollziehbarkeit der Quellen.

---

*Passen Sie dieses Rezept an Ihre spezifischen Dokumenttypen und Anwendungsfälle an.*