---
title: "Filtern"
description: "Lerne, wie du Inhalte bei der Suche mit supermemory filterst"
icon: "list-filter-plus"
---

<div id="container-tag">
  ## Container-Tag
</div>

Ein Container-Tag ist ein Bezeichner für Ihre Endnutzer, mit dem Speicher-Einträge gruppiert werden.

Das kann sein:

- Ein Nutzer, der Ihr Produkt verwendet
- Eine Organisation, die ein SaaS nutzt

Eine Projekt-ID oder sogar eine dynamische wie `user_project_etc`

Wir empfehlen, in allen API-Anfragen einen einzelnen containerTag zu verwenden.

Der Graph wird auf Basis der Container-Tags aufgebaut. Beispielsweise erhält jeder Nutzer bzw. jedes Tag in Ihrem supermemory-Konto einen eigenen Graphen.

<CodeGroup>

```bash cURL
curl https://api.supermemory.ai/v3/search \
  --request POST \
  --header 'Content-Type: application/json' \
  --header 'Authorization: Bearer SUPERMEMORY_API_KEY' \
  --data '{
    "q": "machine learning",
    "containerTags": ["user_123"]
  }'
```

```typescript Typescript
await client.search.execute({
  q: "machine learning",
  containerTags: ["user_123"],
});
```

```python Python
client.search.execute(
    q="machine learning",
    containerTags=["user_123"]
)
```

</CodeGroup>

<div id="metadata">
  ## Metadata
</div>

Manchmal möchten Sie Metadata hinzufügen und darauf basierend erweiterte Filter anwenden.

Mit Metadata-Filterung können Sie suchen nach:

- AND- und OR-Bedingungen
- Zeichenfolgenabgleich
- Numerischem Abgleich
- Datumsabgleich
- Abfragen über Zeitbereiche

<div id="validation-rules-limits">
  ### Validierungsregeln und Limits
</div>

Um optimale Performance und Sicherheit zu gewährleisten, gelten für das Filtersystem folgende Limits:

- **Metadata-Schlüssel**: Dürfen nur alphanumerische Zeichen, Unterstriche und Bindestriche enthalten (`/^[a-zA-Z0-9_-]+$/`)
- **Länge von Metadata-Schlüsseln**: Maximal 64 Zeichen
- **Maximale Anzahl von Bedingungen**: Bis zu 200 Bedingungen pro Abfrage
- **Maximale Verschachtelungstiefe**: Bis zu 8 Ebenen verschachtelter AND/OR-Ausdrücke
- **Zulässige Operatoren**: `=`, `!=`, `<`, `<=`, `>`, `>=` für numerische Filter

<Warning>
Diese Limits verhindern übermäßig komplexe Abfragen, die die Performance beeinträchtigen könnten. Wenn Sie mehr Bedingungen benötigen, teilen Sie Ihre Abfrage in mehrere Requests auf oder verwenden Sie allgemeinere Suchbegriffe mit anschließender Nachbearbeitung.
</Warning>

<CodeGroup>

```bash cURL
curl https://api.supermemory.ai/v3/search \
  --request POST \
  --header 'Content-Type: application/json' \
  --header 'Authorization: Bearer SUPERMEMORY_API_KEY' \
  --data '{
    "q": "machine learning",
    "filters": {
        "AND": [
            {
                "key": "category",
                "value": "technology",
                "negate": false
            },
            {
                "filterType": "numeric",
                "key": "readingTime",
                "value": "5",
                "negate": false,
                "numericOperator": "<="
            }
        ]
    }
}'
```

```typescript Typescript
await client.search.execute({
  q: "machine learning",
  filters: {
    AND: [
      {
        key: "category",
        value: "technology",
        negate: false,
      },
      {
        filterType: "numeric",
        key: "readingTime",
        value: "5",
        negate: false,
        numericOperator: "<=",
      },
    ],
  },
});
```

```python Python
client.search.execute(
    q="machine learning",
    filters={
        "AND": [
            {
                "key": "category",
                "value": "technology",
                "negate": false
            },
            {
                "filterType": "numeric",
                "key": "readingTime",
                "value": "5",
                "negate": false,
                "numericOperator": "<="
            }
        ]
    }
)
```

</CodeGroup>

<div id="array-contains-filtering">
  ## Array-Filterung mit array_contains
</div>

Sie können Speicher anhand von Array-Werten mit dem Filtertyp `array_contains` filtern. Das ist besonders hilfreich, um nach Teilnehmenden oder anderer arraybasierter Metadata zu filtern.

Erstellen Sie zunächst einen Speicher mit Teilnehmenden in der Metadata:

<CodeGroup>

```bash cURL
curl --location 'https://api.supermemory.ai/v3/documents' \
--header 'Content-Type: application/json' \
--header 'Authorization: Bearer SUPERMEMORY_API_KEY' \
--data '{
    "content": "quarterly planning meeting discussion",
    "metadata": {
        "participants": ["john.doe", "sarah.smith", "mike.wilson"]
    }
  }'
```

```typescript Typescript
await client.memories.create({
  content: "quarterly planning meeting discussion",
  metadata: {
    participants: ["john.doe", "sarah.smith", "mike.wilson"]
  }
});
```

```python Python
client.memories.create(
    content="quarterly planning meeting discussion",
    metadata={
        "participants": ["john.doe", "sarah.smith", "mike.wilson"]
    }
)
```

</CodeGroup>

Suchen Sie anschließend mit dem `array_contains`-Filter:

<CodeGroup>

```bash cURL
curl --location 'https://api.supermemory.ai/v3/search' \
--header 'Content-Type: application/json' \
--header 'Authorization: Bearer SUPERMEMORY_API_KEY' \
--data '{
    "q": "meeting",
    "filters": {
      "AND": [
        {
          "key": "participants",
          "value": "john.doe",
          "filterType": "array_contains"
        }
      ]
    },
    "limit": 5
  }'
```

```typescript Typescript
await client.search.execute({
  q: "meeting",
  filters: {
    AND: [
      {
        key: "participants",
        value: "john.doe",
        filterType: "array_contains"
      }
    ]
  },
  limit: 5
});
```

```python Python
client.search.execute(
    q="meeting",
    filters={
        "AND": [
            {
                "key": "participants",
                "value": "john.doe",
                "filterType": "array_contains"
            }
        ]
    },
    limit=5
)
```

</CodeGroup>

<div id="migration-notes">
  ## Migrationshinweise
</div>

<Note>
**Breaking Changes**: Neuere Aktualisierungen des Filtersystems haben strengere Validierungsregeln eingeführt. Wenn Sie auf Filtervalidierungsfehler stoßen, prüfen Sie bitte Folgendes:

1. **Format von Metadata-Schlüsseln**: Stellen Sie sicher, dass alle Metadata-Schlüssel nur alphanumerische Zeichen, Unterstriche und Bindestriche enthalten. Schlüssel mit Leerzeichen, Punkten oder anderen Sonderzeichen schlagen jetzt bei der Validierung fehl.

2. **Schlüssellänge**: Metadata-Schlüssel dürfen maximal 64 Zeichen lang sein.

3. **Filterkomplexität**: Abfragen mit mehr als 200 Bedingungen oder mehr als 8 Verschachtelungsebenen werden abgelehnt.

**Beispiele für ungültige Schlüssel, die aktualisiert werden müssen**:
- `"user.email"` → `"user_email"`
- `"reading time"` → `"reading_time"`
- `"category-with-very-long-name-that-exceeds-the-limit"` → `"category_name"`
</Note>

<div id="document">
  ## Dokument
</div>

Sie können auch Chunks innerhalb eines bestimmten, umfangreichen Dokuments finden.

Das ist besonders nützlich bei äußerst großen Dokumenten wie Büchern, Podcasts usw.

<CodeGroup>

```bash cURL
curl https://api.supermemory.ai/v3/search \
  --request POST \
  --header 'Content-Type: application/json' \
  --header 'Authorization: Bearer SUPERMEMORY_API_KEY' \
  --data '{
    "q": "machine learning",
    "docId": "doc_123"
  }'
```

```typescript Typescript
await client.search.execute({
  q: "machine learning",
  docId: "doc_123",
});
```

```python Python
client.search.execute(
    q="machine learning",
    docId="doc_123"
)
```

</CodeGroup>