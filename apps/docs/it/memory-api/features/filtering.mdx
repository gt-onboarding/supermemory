---
title: "Filtri"
description: "Scopri come applicare filtri ai contenuti durante la ricerca con Supermemory"
icon: "list-filter-plus"
---

<div id="container-tag">
  ## Container Tag
</div>

Il container tag è un identificatore per gli utenti finali, usato per raggruppare le memory.

Può essere:

- Un utente che usa il tuo prodotto
- Un'organizzazione che utilizza un SaaS

Un ID di progetto, o anche uno dinamico come `user_project_etc`

Consigliamo di utilizzare un singolo containerTag in tutte le richieste API.

Il grafo è costruito sui Container Tags. Ad esempio, ogni utente/tag nel tuo account Supermemory avrà un unico grafo dedicato.

<CodeGroup>

```bash cURL
curl https://api.supermemory.ai/v3/search \
  --request POST \
  --header 'Content-Type: application/json' \
  --header 'Authorization: Bearer SUPERMEMORY_API_KEY' \
  --data '{
    "q": "machine learning",
    "containerTags": ["user_123"]
  }'
```

```typescript Typescript
await client.search.execute({
  q: "machine learning",
  containerTags: ["user_123"],
});
```

```python Python
client.search.execute(
    q="machine learning",
    containerTags=["user_123"]
)
```

</CodeGroup>

<div id="metadata">
  ## Metadata
</div>

A volte potresti voler aggiungere metadata ed eseguire filtri avanzati basati su di essi.

Utilizzando il filtraggio per metadata, puoi cercare in base a:

- Condizioni AND e OR
- Corrispondenza di stringhe
- Corrispondenza numerica
- Corrispondenza di date
- Query su intervalli temporali

<div id="validation-rules-limits">
  ### Regole di convalida e limiti
</div>

Per garantire prestazioni e sicurezza ottimali, il sistema di filtraggio applica i seguenti limiti:

- **Chiavi dei metadata**: possono contenere solo caratteri alfanumerici, underscore e trattini (`/^[a-zA-Z0-9_-]+$/`)
- **Lunghezza delle chiavi dei metadata**: massimo 64 caratteri
- **Numero massimo di condizioni**: fino a 200 condizioni per query
- **Profondità massima di annidamento**: fino a 8 livelli di espressioni AND/OR annidate
- **Operatori validi**: `=`, `!=`, `<`, `<=`, `>`, `>=` per il filtraggio numerico

<Warning>
Questi limiti aiutano a prevenire query eccessivamente complesse che potrebbero incidere sulle prestazioni. Se devi filtrare su più condizioni, valuta di suddividere la query in più richieste o di utilizzare termini di ricerca più ampi con una post‑elaborazione successiva.
</Warning>

<CodeGroup>

```bash cURL
curl https://api.supermemory.ai/v3/search \
  --request POST \
  --header 'Content-Type: application/json' \
  --header 'Authorization: Bearer SUPERMEMORY_API_KEY' \
  --data '{
    "q": "machine learning",
    "filters": {
        "AND": [
            {
                "key": "category",
                "value": "technology",
                "negate": false
            },
            {
                "filterType": "numeric",
                "key": "readingTime",
                "value": "5",
                "negate": false,
                "numericOperator": "<="
            }
        ]
    }
}'
```

```typescript Typescript
await client.search.execute({
  q: "machine learning",
  filters: {
    AND: [
      {
        key: "category",
        value: "technology",
        negate: false,
      },
      {
        filterType: "numeric",
        key: "readingTime",
        value: "5",
        negate: false,
        numericOperator: "<=",
      },
    ],
  },
});
```

```python Python
client.search.execute(
    q="machine learning",
    filters={
        "AND": [
            {
                "key": "category",
                "value": "technology",
                "negate": false
            },
            {
                "filterType": "numeric",
                "key": "readingTime",
                "value": "5",
                "negate": false,
                "numericOperator": "<="
            }
        ]
    }
)
```

</CodeGroup>

<div id="array-contains-filtering">
  ## Filtro array_contains
</div>

Puoi filtrare le memory in base ai valori di un array usando il tipo di filtro `array_contains`. È particolarmente utile per filtrare per partecipanti o altra metadata basata su array.

Per prima cosa, crea una memory con i partecipanti nella metadata:

<CodeGroup>

```bash cURL
curl --location 'https://api.supermemory.ai/v3/documents' \
--header 'Content-Type: application/json' \
--header 'Authorization: Bearer SUPERMEMORY_API_KEY' \
--data '{
    "content": "quarterly planning meeting discussion",
    "metadata": {
        "participants": ["john.doe", "sarah.smith", "mike.wilson"]
    }
  }'
```

```typescript Typescript
await client.memories.create({
  content: "quarterly planning meeting discussion",
  metadata: {
    participants: ["john.doe", "sarah.smith", "mike.wilson"]
  }
});
```

```python Python
client.memories.create(
    content="quarterly planning meeting discussion",
    metadata={
        "participants": ["john.doe", "sarah.smith", "mike.wilson"]
    }
)
```

</CodeGroup>

Poi esegui la ricerca usando il filtro `array_contains`:

<CodeGroup>

```bash cURL
curl --location 'https://api.supermemory.ai/v3/search' \
--header 'Content-Type: application/json' \
--header 'Authorization: Bearer SUPERMEMORY_API_KEY' \
--data '{
    "q": "meeting",
    "filters": {
      "AND": [
        {
          "key": "participants",
          "value": "john.doe",
          "filterType": "array_contains"
        }
      ]
    },
    "limit": 5
  }'
```

```typescript Typescript
await client.search.execute({
  q: "meeting",
  filters: {
    AND: [
      {
        key: "participants",
        value: "john.doe",
        filterType: "array_contains"
      }
    ]
  },
  limit: 5
});
```

```python Python
client.search.execute(
    q="meeting",
    filters={
        "AND": [
            {
                "key": "participants",
                "value": "john.doe",
                "filterType": "array_contains"
            }
        ]
    },
    limit=5
)
```

</CodeGroup>

<div id="migration-notes">
  ## Note di migrazione
</div>

<Note>
**Modifiche incompatibili**: Gli aggiornamenti recenti al sistema di filtraggio hanno introdotto regole di validazione più rigorose. Se riscontri errori di validazione dei filtri, verifica quanto segue:

1. **Formato delle chiavi di metadata**: Assicurati che tutte le chiavi di metadata contengano solo caratteri alfanumerici, underscore e trattini. Le chiavi con spazi, punti o altri caratteri speciali ora non supereranno la validazione.

2. **Lunghezza delle chiavi**: Le chiavi di metadata devono avere 64 caratteri o meno.

3. **Complessità del filtro**: Le query con più di 200 condizioni o più di 8 livelli di annidamento verranno rifiutate.

**Esempi di chiavi non valide che richiedono aggiornamento**:
- `"user.email"` → `"user_email"`
- `"reading time"` → `"reading_time"`
- `"category-with-very-long-name-that-exceeds-the-limit"` → `"category_name"`
</Note>

<div id="document">
  ## Documento
</div>

Puoi anche trovare chunk all’interno di un documento specifico di grandi dimensioni.

Questo è particolarmente utile per documenti molto voluminosi, come libri, podcast, ecc.

<CodeGroup>

```bash cURL
curl https://api.supermemory.ai/v3/search \
  --request POST \
  --header 'Content-Type: application/json' \
  --header 'Authorization: Bearer SUPERMEMORY_API_KEY' \
  --data '{
    "q": "machine learning",
    "docId": "doc_123"
  }'
```

```typescript Typescript
await client.search.execute({
  q: "machine learning",
  docId: "doc_123",
});
```

```python Python
client.search.execute(
    q="machine learning",
    docId="doc_123"
)
```

</CodeGroup>