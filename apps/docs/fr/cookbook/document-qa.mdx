---
title: "Système de questions-réponses sur les documents"
description: "Créez un chatbot qui répond aux questions à partir de vos documents, avec citations et références"
---

Créez un système de questions-réponses puissant pour vos documents, capable d’ingérer des PDF, des fichiers texte et des pages web, puis de répondre aux questions avec des citations précises. Idéal pour les sites de documentation, les bases de recherche ou les bases de connaissances internes.

<div id="what-youll-build">
  ## Ce que vous allez construire
</div>

Un système de questions-réponses sur des documents qui :

- **Ingeste plusieurs types de fichiers** (PDF, DOCX, texte, URL)
- **Répond avec précision aux questions** avec des références de source
- **Fournit des références de source** avec numéros de page et titres de documents
- **Gère les questions de suivi** en tenant compte du contexte de la conversation
- **Prend en charge plusieurs collections de documents** pour différents sujets

<div id="prerequisites">
  ## Prérequis
</div>

- Node.js 18+ ou Python 3.8+
- Clé d’API Supermemory
- Clé d’API OpenAI
- Connaissances de base en gestion des fichiers

<div id="implementation">
  ## Implémentation
</div>

<div id="step-1-document-processing-system">
  ### Étape 1 : Système de traitement de documents
</div>

<Tabs>
  <Tab title="Next.js">
    ```typescript lib/document-processor.ts
    import { Supermemory } from 'supermemory'

    const client = new Supermemory({
      apiKey: process.env.SUPERMEMORY_API_KEY!
    })

    interface DocumentUpload {
      file: File
      collection: string
      metadata?: Record<string, any>
    }

    export class DocumentProcessor {
      async uploadDocument({ file, collection, metadata = {} }: DocumentUpload) {
        try {
          const formData = new FormData()
          formData.append('file', file)
          formData.append('containerTags', JSON.stringify([collection]))
          formData.append('metadata', JSON.stringify({
            originalName: file.name,
            fileType: file.type,
            uploadedAt: new Date().toISOString(),
            ...metadata
          }))

          const response = await fetch('/api/upload-document', {
            method: 'POST',
            body: formData
          })

          if (!response.ok) {
            throw new Error(`Échec du téléversement : ${response.statusText}`)
          }

          return await response.json()
        } catch (error) {
          console.error('Erreur de téléversement de document :', error)
          throw error
        }
      }

      async uploadURL({ url, collection, metadata = {} }: { url: string, collection: string, metadata?: Record<string, any> }) {
        try {
          const result = await client.memories.add({
            content: url,
            containerTag: collection,
            metadata: {
              type: 'url',
              originalUrl: url,
              uploadedAt: new Date().toISOString(),
              ...metadata
            }
          })

          return result
        } catch (error) {
          console.error('Erreur de téléversement d\'URL :', error)
          throw error
        }
      }

      async getDocumentStatus(documentId: string) {
        try {
          const memory = await client.memories.get(documentId)
          return {
            id: memory.id,
            status: memory.status,
            title: memory.title,
            progress: memory.metadata?.progress || 0
          }
        } catch (error) {
          console.error('Erreur de vérification du status :', error)
          throw error
        }
      }

      async listDocuments(collection: string) {
        try {
          const memories = await client.memories.list({
            containerTags: [collection],
            limit: 50,
            sort: 'updatedAt',
            order: 'desc'
          })

          return memories.memories.map(memory => ({
            id: memory.id,
            title: memory.title || memory.metadata?.originalName || 'Sans titre',
            type: memory.metadata?.fileType || memory.metadata?.type || 'inconnu',
            uploadedAt: memory.metadata?.uploadedAt,
            status: memory.status,
            url: memory.metadata?.originalUrl
          }))
        } catch (error) {
          console.error('Erreur de listage des documents :', error)
          throw error
        }
      }
    }
    ```

    ```typescript app/api/upload-document/route.ts
    import { NextRequest, NextResponse } from 'next/server'
    import { Supermemory } from 'supermemory'

    const client = new Supermemory({
      apiKey: process.env.SUPERMEMORY_API_KEY!
    })

    export async function POST(request: NextRequest) {
      try {
        const formData = await request.formData()
        const file = formData.get('file') as File
        const containerTags = JSON.parse(formData.get('containerTags') as string)
        const metadata = JSON.parse(formData.get('metadata') as string || '{}')

        if (!file) {
          return NextResponse.json({ error: 'Aucun fichier fourni' }, { status: 400 })
        }

        // Convertir le fichier en Buffer pour Supermemory
        const bytes = await file.arrayBuffer()
        const buffer = Buffer.from(bytes)

        const result = await client.memories.uploadFile({
          file: buffer,
          filename: file.name,
          containerTags,
          metadata
        })

        return NextResponse.json({
          success: true,
          documentId: result.id,
          message: 'Document téléversé avec succès'
        })

      } catch (error) {
        console.error('Erreur de téléversement:', error)
        return NextResponse.json(
          { error: 'Échec du téléversement', details: error.message },
          { status: 500 }
        )
      }
    }
    ```
  </Tab>

  <Tab title="Python">
    ```python document_processor.py
    from supermemory import Supermemory
    import os
    from typing import Dict, List, Any, Optional
    import requests
    from datetime import datetime

    class DocumentProcessor:
        def __init__(self):
            self.client = Supermemory(api_key=os.getenv("SUPERMEMORY_API_KEY"))

        def upload_file(self, file_path: str, collection: str, metadata: Dict[str, Any] = None) -> Dict:
            """Téléverser un fichier local vers Supermemory"""
            if metadata is None:
                metadata = {}

            try:
                with open(file_path, 'rb') as file:
                    result = self.client.memories.upload_file(
                        file=file,
                        container_tags=[collection],
                        metadata={
                            'originalName': os.path.basename(file_path),
                            'fileType': os.path.splitext(file_path)[1],
                            'uploadedAt': datetime.now().isoformat(),
                            **metadata
                        }
                    )
                return result
            except Exception as e:
                print(f"Erreur lors du téléversement du fichier : {e}")
                raise

        def upload_url(self, url: str, collection: str, metadata: Dict[str, Any] = None) -> Dict:
            """Téléverser le contenu d'une URL vers Supermemory"""
            if metadata is None:
                metadata = {}

            try:
                result = self.client.memories.add(
                    content=url,
                    container_tag=collection,
                    metadata={
                        'type': 'url',
                        'originalUrl': url,
                        'uploadedAt': datetime.now().isoformat(),
                        **metadata
                    }
                )
                return result
            except Exception as e:
                print(f"Erreur lors du téléversement de l'URL : {e}")
                raise

        def get_document_status(self, document_id: str) -> Dict:
            """Vérifier le status de traitement du document"""
            try:
                memory = self.client.memories.get(document_id)
                return {
                    'id': memory.id,
                    'status': memory.status,
                    'title': memory.title,
                    'progress': memory.metadata.get('progress', 0) if memory.metadata else 0
                }
            except Exception as e:
                print(f"Erreur lors de la vérification du status : {e}")
                raise

        def list_documents(self, collection: str) -> List[Dict]:
            """Lister tous les documents d'une collection"""
            try:
                memories = self.client.memories.list(
                    container_tags=[collection],
                    limit=50,
                    sort='updatedAt',
                    order='desc'
                )

                return [
                    {
                        'id': memory.id,
                        'title': (memory.title or
                                memory.metadata.get('originalName') or
                                'Sans titre' if memory.metadata else 'Sans titre'),
                        'type': (memory.metadata.get('fileType') or
                               memory.metadata.get('type') or
                               'inconnu' if memory.metadata else 'inconnu'),
                        'uploadedAt': memory.metadata.get('uploadedAt') if memory.metadata else None,
                        'status': memory.status,
                        'url': memory.metadata.get('originalUrl') if memory.metadata else None
                    }
                    for memory in memories.memories
                ]
            except Exception as e:
                print(f"Erreur lors du listage des documents : {e}")
                raise
    ```
  </Tab>
</Tabs>

<div id="step-2-qa-api-with-citations">
  ### Étape 2 : API de questions-réponses avec références
</div>

<Tabs>
  <Tab title="Route API Next.js">
    ```typescript app/api/qa/route.ts
    import { streamText } from 'ai'
    import { createOpenAI } from '@ai-sdk/openai'
    import { Supermemory } from 'supermemory'

    const openai = createOpenAI({
      apiKey: process.env.OPENAI_API_KEY!
    })

    const client = new Supermemory({
      apiKey: process.env.SUPERMEMORY_API_KEY!
    })

    export async function POST(request: Request) {
      const { question, collection, conversationHistory = [] } = await request.json()

      try {
        // Rechercher les documents pertinents
        const searchResults = await client.search.documents({
          q: question,
          containerTags: [collection],
          limit: 8,
          rerank: true,
          includeFullDocs: false,
          includeSummary: true,
          onlyMatchingChunks: false,
          documentThreshold: 0.6,
          chunkThreshold: 0.7
        })

        if (searchResults.results.length === 0) {
          return Response.json({
            answer: "Je n'ai trouvé aucune information pertinente dans les documents téléchargés pour répondre à votre question.",
            sources: [],
            confidence: 0
          })
        }

        // Préparer le contexte à partir des résultats de recherche
        const context = searchResults.results.map((result, index) => {
          const chunks = result.chunks
            .filter(chunk => chunk.isRelevant)
            .slice(0, 3)
            .map(chunk => chunk.content)
            .join('\n\n')

          return `[Document ${index + 1} : "${result.title}"]\n${chunks}`
        }).join('\n\n---\n\n')

        // Préparer les sources pour la citation
        const sources = searchResults.results.map((result, index) => ({
          id: result.documentId,
          title: result.title,
          type: result.type,
          relevantChunks: result.chunks.filter(chunk => chunk.isRelevant).length,
          score: result.score,
          citationNumber: index + 1
        }))

        const messages = [
          ...conversationHistory,
          {
            role: 'user' as const,
            content: question
          }
        ]

        const result = await streamText({
          model: openai('gpt-5'),
          messages,
          system: `Vous êtes un assistant de questions-réponses documentaires utile. Répondez aux questions en vous basant UNIQUEMENT sur le contexte des documents fournis.

    CONTEXTE DES DOCUMENTS :
    ${context}

    INSTRUCTIONS :
    1. Répondez à la question en utilisant UNIQUEMENT les informations des documents fournis
    2. Incluez des citations spécifiques dans votre réponse en utilisant le format [Document X]
    3. Si les documents ne contiennent pas suffisamment d'informations, dites-le clairement
    4. Soyez précis et citez directement lorsque c'est possible
    5. Si plusieurs documents appuient un point, citez tous ceux qui sont pertinents
    6. Adoptez un ton utile et professionnel

    FORMAT DE CITATION :
    - Utilisez [Document 1], [Document 2], etc. pour citer les sources
    - Placez les citations après les informations pertinentes
    - Exemple : "Le processus comprend trois étapes [Document 1]. Cependant, certains experts recommandent une approche en quatre étapes [Document 3]."

    Si la question ne peut pas être répondue à partir des documents fournis, répondez par : "Je n'ai pas suffisamment d'informations dans les documents fournis pour répondre à cette question avec précision."`,
          temperature: 0.1,
          maxTokens: 1000
        })

        return result.toAIStreamResponse({
          data: {
            sources,
            searchResultsCount: searchResults.results.length,
            totalResults: searchResults.total
          }
        })

      } catch (error) {
        console.error('Erreur Q&R :', error)
        return Response.json(
          { error: 'Échec du traitement de la question', details: error.message },
          { status: 500 }
        )
      }
    }
    ```
  </Tab>

  <Tab title="Python FastAPI">
    ```python qa_api.py
    from fastapi import FastAPI, HTTPException
    from fastapi.responses import StreamingResponse
    from pydantic import BaseModel
    from typing import List, Dict, Any, Optional
    import openai
    from supermemory import Supermemory
    import json
    import os

    app = FastAPI()

    openai_client = openai.AsyncOpenAI(api_key=os.getenv("OPENAI_API_KEY"))
    supermemory_client = Supermemory(api_key=os.getenv("SUPERMEMORY_API_KEY"))

    class QARequest(BaseModel):
        question: str
        collection: str
        conversationHistory: List[Dict[str, str]] = []

    class QAResponse(BaseModel):
        answer: str
        sources: List[Dict[str, Any]]
        confidence: float
        searchResultsCount: int

    @app.post("/qa")
    async def answer_question(request: QARequest):
        try:
            # Rechercher les documents pertinents
            search_results = supermemory_client.search.documents(
                q=request.question,
                container_tags=[request.collection],
                limit=8,
                rerank=True,
                include_full_docs=False,
                include_summary=True,
                only_matching_chunks=False,
                document_threshold=0.6,
                chunk_threshold=0.7
            )

            if not search_results.results:
                return QAResponse(
                    answer="Je n'ai trouvé aucune information pertinente dans les documents téléchargés pour répondre à votre question.",
                    sources=[],
                    confidence=0,
                    searchResultsCount=0
                )

            # Préparer le contexte à partir des résultats de recherche
            context_parts = []
            sources = []

            for index, result in enumerate(search_results.results):
                relevant_chunks = [
                    chunk.content for chunk in result.chunks
                    if chunk.is_relevant
                ][:3]

                chunk_text = '\n\n'.join(relevant_chunks)
                context_parts.append(f'[Document {index + 1}: "{result.title}"]\n{chunk_text}')

                sources.append({
                    'id': result.document_id,
                    'title': result.title,
                    'type': result.type,
                    'relevantChunks': len([c for c in result.chunks if c.is_relevant]),
                    'score': result.score,
                    'citationNumber': index + 1
                })

            context = '\n\n---\n\n'.join(context_parts)

            # Préparer les messages
            messages = [
                {
                    "role": "system",
                    "content": f"""Vous êtes un assistant Q&R spécialisé dans l'analyse de documents. Répondez aux questions en vous basant UNIQUEMENT sur le contexte documentaire fourni.

    CONTEXTE DES DOCUMENTS :
    {context}

    INSTRUCTIONS :
    1. Répondez à la question en utilisant UNIQUEMENT les informations des documents fournis
    2. Incluez des citations spécifiques dans votre réponse en utilisant le format [Document X]
    3. Si les documents ne contiennent pas suffisamment d'informations, indiquez-le clairement
    4. Soyez précis et citez directement lorsque c'est possible
    5. Si plusieurs documents appuient un point, citez tous ceux qui sont pertinents
    6. Adoptez un ton professionnel et utile

    FORMAT DE CITATION :
    - Utilisez [Document 1], [Document 2], etc. pour citer les sources
    - Placez les citations après les informations pertinentes
    - Exemple : "Le processus comprend trois étapes [Document 1]. Cependant, certains experts recommandent une approche en quatre étapes [Document 3]."

    Si la question ne peut pas être répondue à partir des documents fournis, répondez par : "Je ne dispose pas d'informations suffisantes dans les documents fournis pour répondre à cette question avec précision." """
                }
            ]

            # Ajouter l'historique de conversation
            messages.extend(request.conversationHistory)
            messages.append({"role": "user", "content": request.question})

            # Obtenir la réponse de l'IA
            response = await openai_client.chat.completions.create(
                model="gpt-5",
                messages=messages,
                temperature=0.1,
                max_tokens=1000
            )

            answer = response.choices[0].message.content

            return QAResponse(
                answer=answer,
                sources=sources,
                confidence=min(search_results.results[0].score if search_results.results else 0, 1.0),
                searchResultsCount=len(search_results.results)
            )

        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Échec du traitement de la question : {str(e)}")

    if __name__ == "__main__":
        import uvicorn
        uvicorn.run(app, host="0.0.0.0", port=8000)
    ```
  </Tab>
</Tabs>

<div id="step-3-frontend-interface">
  ### Étape 3 : Interface front-end
</div>

```tsx app/qa/page.tsx
'use client'

import { useState, useRef } from 'react'
import { useChat } from 'ai/react'
import { DocumentProcessor } from '@/lib/document-processor'

interface Document {
  id: string
  title: string
  type: string
  status: string
  uploadedAt: string
}

interface Source {
  id: string
  title: string
  citationNumber: number
  score: number
  relevantChunks: number
}

export default function DocumentQA() {
  const [collection, setCollection] = useState('default-docs')
  const [documents, setDocuments] = useState<Document[]>([])
  const [sources, setSources] = useState<Source[]>([])
  const [isUploading, setIsUploading] = useState(false)
  const [uploadProgress, setUploadProgress] = useState<Record<string, number>>({})
  const fileInputRef = useRef<HTMLInputElement>(null)

  const processor = new DocumentProcessor()

  const { messages, input, handleInputChange, handleSubmit, isLoading } = useChat({
    api: '/api/qa',
    body: {
      collection
    },
    onFinish: (message, { data }) => {
      if (data?.sources) {
        setSources(data.sources)
      }
    }
  })

  const handleFileUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const files = event.target.files
    if (!files || files.length === 0) return

    setIsUploading(true)
    const newProgress: Record<string, number> = {}

    try {
      for (const file of Array.from(files)) {
        newProgress[file.name] = 0
        setUploadProgress({ ...newProgress })

        await processor.uploadDocument({
          file,
          collection,
          metadata: {
            uploadedBy: 'user',
            category: 'qa-document'
          }
        })

        newProgress[file.name] = 100
        setUploadProgress({ ...newProgress })
      }

      // Refresh document list
      await loadDocuments()

      // Clear file input
      if (fileInputRef.current) {
        fileInputRef.current.value = ''
      }

    } catch (error) {
      console.error('Upload failed:', error)
      alert('Upload failed: ' + error.message)
    } finally {
      setIsUploading(false)
      setUploadProgress({})
    }
  }

  const loadDocuments = async () => {
    try {
      const docs = await processor.listDocuments(collection)
      setDocuments(docs)
    } catch (error) {
      console.error('Failed to load documents:', error)
    }
  }

  const formatSources = (sources: Source[]) => {
    if (!sources || sources.length === 0) return null

    return (
      <div className="mt-4 p-4 bg-gray-50 border border-gray-200 rounded-lg">
        <h3 className="text-sm font-semibold text-gray-700 mb-2">Sources :</h3>
        <div className="space-y-2">
          {sources.map((source) => (
            <div key={source.id} className="flex items-center space-x-2 text-sm">
              <span className="bg-blue-100 text-blue-800 px-2 py-1 rounded text-xs font-mono">
                Document {source.citationNumber}
              </span>
              <span className="text-gray-700">{source.title}</span>
              <span className="text-gray-500">
                ({source.relevantChunks} segments pertinents, {(source.score * 100).toFixed(1)} % de correspondance)
              </span>
            </div>
          ))}
        </div>
      </div>
    )
  }

  return (
    <div className="max-w-6xl mx-auto p-6">
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* Panneau de gestion des documents */}
        <div className="lg:col-span-1">
          <div className="bg-white border border-gray-200 rounded-lg p-6">
            <h2 className="text-lg font-semibold mb-4">Collection de documents</h2>

            {/* Sélecteur de collection */}
            <div className="mb-4">
              <label className="block text-sm font-medium text-gray-700 mb-2">
                Nom de la collection
              </label>
              <input
                type="text"
                value={collection}
                onChange={(e) => setCollection(e.target.value)}
                className="w-full p-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                placeholder="ex. : docs-entreprise"
              />
            </div>

            {/* Import de fichiers */}
            <div className="mb-4">
              <input
                ref={fileInputRef}
                type="file"
                multiple
                accept=".pdf,.docx,.txt,.md"
                onChange={handleFileUpload}
                className="hidden"
              />
              <button
                onClick={() => fileInputRef.current?.click()}
                disabled={isUploading}
                className="w-full p-3 border-2 border-dashed border-gray-300 rounded-lg hover:border-blue-400 focus:ring-2 focus:ring-blue-500 disabled:opacity-50"
              >
                {isUploading ? 'Import en cours...' : 'Importer des documents'}
              </button>
            </div>

            {/* Progression de l'import */}
            {Object.keys(uploadProgress).length > 0 && (
              <div className="mb-4 space-y-2">
                {Object.entries(uploadProgress).map(([filename, progress]) => (
                  <div key={filename} className="text-sm">
                    <div className="flex justify-between">
                      <span className="truncate">{filename}</span>
                      <span>{progress} %</span>
                    </div>
                    <div className="w-full bg-gray-200 rounded-full h-2">
                      <div
                        className="bg-blue-600 h-2 rounded-full transition-all duration-300"
                        style={{ width: `${progress}%` }}
                      />
                    </div>
                  </div>
                ))}
              </div>
            )}

            {/* Liste des documents */}
            <div className="max-h-64 overflow-y-auto">
              {documents.map((doc) => (
                <div key={doc.id} className="mb-2 p-2 bg-gray-50 rounded text-sm">
                  <div className="font-medium truncate">{doc.title}</div>
                  <div className="text-gray-500 text-xs">
                    {doc.type} • {doc.status}
                  </div>
                </div>
              ))}
            </div>

            <button
              onClick={loadDocuments}
              className="w-full mt-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
            >
              Actualiser les documents
            </button>
          </div>
        </div>

        {/* Interface de questions-réponses */}
        <div className="lg:col-span-2">
          <div className="bg-white border border-gray-200 rounded-lg p-6">
            <h2 className="text-lg font-semibold mb-4">Poser des questions</h2>

            {/* Messages */}
            <div className="h-96 overflow-y-auto mb-4 space-y-4">
              {messages.length === 0 && (
                <div className="text-gray-500 text-center py-8">
                  Importez des documents et posez des questions pour commencer !

                  <div className="mt-4 text-sm">
                    <p className="font-medium">Essayez de demander :</p>
                    <ul className="mt-2 space-y-1">
                      <li>« Quels sont les principaux résultats ? »</li>
                      <li>« Résumez les points clés »</li>
                      <li>« Que dit la section 3 à propos de... ? »</li>
                    </ul>
                  </div>
                </div>
              )}

              {messages.map((message) => (
                <div
                  key={message.id}
                  className={`p-4 rounded-lg ${
                    message.role === 'user'
                      ? 'bg-blue-500 text-white ml-8'
                      : 'bg-gray-100 mr-8'
                  }`}
                >
                  <div className="whitespace-pre-wrap">{message.content}</div>

                  {message.role === 'assistant' && sources.length > 0 && (
                    formatSources(sources)
                  )}
                </div>
              ))}

              {isLoading && (
                <div className="bg-gray-100 p-4 rounded-lg mr-8">
                  <div className="flex items-center space-x-2">
                    <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600"></div>
                    <span>Recherche dans les documents et génération de la réponse...</span>
                  </div>
                </div>
              )}
            </div>

            {/* Input */}
            <form onSubmit={handleSubmit} className="flex gap-2">
              <input
                value={input}
                onChange={handleInputChange}
                placeholder="Posez une question sur vos documents..."
                className="flex-1 p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                disabled={isLoading || documents.length === 0}
              />
              <button
                type="submit"
                disabled={isLoading || !input.trim() || documents.length === 0}
                className="px-6 py-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                Poser
              </button>
            </form>

            {documents.length === 0 && (
              <p className="text-sm text-gray-500 mt-2">
                Téléchargez d'abord des documents pour pouvoir poser des questions
              </p>
            )}
          </div>
        </div>
      </div>
    </div>
  )
}
```

<div id="testing-your-qa-system">
  ## Tester votre système de questions-réponses
</div>

<div id="step-4-test-document-processing">
  ### Étape 4 : Tester le traitement des documents
</div>

1. **Téléverser des documents de test** :
   - Téléversez un manuel PDF ou un article de recherche
   - Ajoutez quelques articles web via url
   - Téléversez quelques fichiers texte sur différents sujets

2. **Tester les types de questions** :
   ```
   Factuelle : « Quelle est la définition de X mentionnée dans les documents ? »
   Analytique : « Quels sont les avantages et les inconvénients de l’approche Y ? »
   Comparative : « Comment la méthode A se compare-t-elle à la méthode B ? »
   Résumé : « Résumez les principaux résultats »
   ```

3. **Vérifier les citations** :
   - Vérifiez que des citations apparaissent dans les réponses
   - Vérifiez que les numéros de citation correspondent à la liste des sources
   - Assurez-vous que les sources affichent des Metadata pertinentes

<div id="production-considerations">
  ## Considérations pour la mise en production
</div>

<div id="performance-optimization">
  ### Optimisation des performances
</div>

```typescript
// Implémente la mise en cache pour les questions fréquemment posées
const cacheKey = `qa:${collection}:${hashQuery(question)}`
const cachedResponse = await redis.get(cacheKey)

if (cachedResponse) {
  return JSON.parse(cachedResponse)
}

// Met en cache la réponse pendant 1 heure
await redis.setex(cacheKey, 3600, JSON.stringify(response))
```


<div id="advanced-features">
  ### Fonctionnalités avancées
</div>

1. **Questions de suivi** :
   ```typescript
   // Suivre le contexte de la conversation
   const conversationHistory = messages.slice(-6) // 3 derniers échanges
   ```

2. **Score de confiance de la réponse** :
   ```typescript
   const confidence = calculateConfidence({
     searchScore: searchResults.results[0]?.score || 0,
     resultCount: searchResults.results.length,
     chunkRelevance: avgChunkRelevance
   })
   ```

3. **Prise en charge multilingue** :
   ```typescript
   // Détecter la langue du document et adapter la recherche
   const detectedLanguage = await detectLanguage(question)
   const searchResults = await client.search.documents({
     q: question,
     filters: {
       AND: [{ key: 'language', value: detectedLanguage }]
     }
   })
   ```

Cette recette constitue une base complète pour créer des systèmes de questions-réponses sur documents avec des citations précises et un suivi des sources.

---

*Personnalisez cette recette en fonction de vos types de documents et de vos cas d’usage spécifiques.*