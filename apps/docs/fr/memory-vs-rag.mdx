---
title: "Memory vs RAGÂ : comprendre la diffÃ©rence"
description: "DÃ©couvrez pourquoi la memory dâ€™agent et le RAG sont fondamentalement diffÃ©rents, et quand utiliser chaque approche"
sidebarTitle: "Memory vs RAG"
---

La plupart des dÃ©veloppeurs confondent le RAG (Retrieval-Augmented Generation) avec la memory dâ€™un agent. Ce ne sont pas la mÃªme chose, et utiliser le RAG pour la memory explique pourquoi vos agents oublient sans cesse des Ã©lÃ©ments de contexte importants. Voyons la diffÃ©rence fondamentale.

<div id="the-core-problem">
  ## Le problÃ¨me central
</div>

Lors de la crÃ©ation dâ€™agents IA, les dÃ©veloppeurs traitent souvent la memory comme un simple problÃ¨me de recherche. Ils stockent les conversations dans une base de donnÃ©es vectorielle, gÃ©nÃ¨rent des embeddings pour les requÃªtes et espÃ¨rent que la recherche sÃ©mantique fera ressortir le bon contexte.

**Cette approche Ã©choue parce que la memory ne consiste pas Ã  retrouver un texte similaire â€” il sâ€™agit de comprendre les relations, le contexte temporel et lâ€™Ã©tat de lâ€™utilisateur au fil du temps.**

<div id="documents-vs-memories-in-supermemory">
  ## Documents vs Memories in Supermemory
</div>

Supermemory opÃ¨re une distinction nette entre ces deux conceptsÂ :

<div id="documents-raw-knowledge">
  ### DocumentsÂ : connaissances brutes
</div>

Les documents sont le contenu brut que vous envoyez Ã  Supermemory â€” PDF, pages web, fichiers texte. Ils reprÃ©sentent une connaissance statique qui ne change pas selon la personne qui y accÃ¨de.

**CaractÃ©ristiquesÂ :**

- **Sans Ã©tat**Â : un document sur la programmation Python est le mÃªme pour tout le monde
- **Non versionnÃ©**Â : le contenu ne trace pas les modifications au fil du temps
- **Universel**Â : non liÃ© Ã  des utilisateurs ou entitÃ©s spÃ©cifiques
- **Recherchable**Â : idÃ©al pour la recherche par similaritÃ© sÃ©mantique

**Cas dâ€™usageÂ :**

- Bases de connaissances dâ€™entreprise
- Documentation technique
- Articles de recherche
- Documents de rÃ©fÃ©rence gÃ©nÃ©raux

<div id="memories-contextual-understanding">
  ### MemoriesÂ : comprÃ©hension contextuelle
</div>

Les memories sont les informations, prÃ©fÃ©rences et relations extraites des documents et des conversations. Elles sont liÃ©es Ã  des utilisateurs ou des entitÃ©s spÃ©cifiques et Ã©voluent au fil du temps.

**CaractÃ©ristiquesÂ :**

- **Avec Ã©tat**Â : Â«Â User prefers dark modeÂ Â» est propre Ã  cet utilisateur
- **Temporelles**Â : Suit le moment oÃ¹ des faits deviennent vrais ou cessent de lâ€™Ãªtre
- **Personnelles**Â : LiÃ©es aux utilisateurs, sessions ou entitÃ©s
- **Relationnelles**Â : Comprend les relations entre les faits

**Cas dâ€™usageÂ :**

- PrÃ©fÃ©rences et historique utilisateur
- Contexte conversationnel
- Faits personnels et relations
- SchÃ©mas comportementaux

<div id="why-rag-fails-as-memory">
  ## Pourquoi le RAG Ã©choue comme memory
</div>

Voyons un scÃ©nario concret qui illustre le problÃ¨meÂ :

<Tabs>
  <Tab title="The Scenario">
    ```
    Jour 1 : "Jâ€™adore les sneakers Adidas"
    Jour 30 : "Mes Adidas se sont cassÃ©es aprÃ¨s un mois, qualitÃ© terrible"
    Jour 31 : "Je passe chez Puma"
    Jour 45 : "Quelles sneakers devrais-je acheter ?"
    ```
  </Tab>

  <Tab title="RAG Approach (Wrong)">
    ```python
    # Le RAG voit ces Ã©lÃ©ments comme des embeddings isolÃ©s
    query = "Quelles sneakers devrais-je acheter ?"

    # La recherche sÃ©mantique trouve la correspondance la plus proche
    result = vector_search(query)
    # Renvoie : "Jâ€™adore les sneakers Adidas" (plus haute similaritÃ©)

    # Lâ€™agent recommande Adidas ğŸ¤¦
    ```

    **ProblÃ¨me** : le RAG trouve le texte le plus proche sÃ©mantiquement mais ignore la progression temporelle et les relations causales.
  </Tab>

  <Tab title="Memory Approach (Right)">
    ```python
    # Supermemory comprend le contexte temporel
    query = "Quelles sneakers devrais-je acheter ?"

    # La rÃ©cupÃ©ration de memory prend en compte :
    # 1. La validitÃ© temporelle (la prÃ©fÃ©rence Adidas est obsolÃ¨te)
    # 2. Les relations causales (cassÃ©es â†’ dÃ©ception â†’ changement)
    # 3. Lâ€™Ã©tat actuel (prÃ©fÃ©rence actuelle pour Puma)

    # Lâ€™agent recommande correctement Puma âœ…
    ```

    **Solution** : les systÃ¨mes de memory suivent quand les faits deviennent invalides et comprennent les chaÃ®nes causales.
  </Tab>
</Tabs>

<div id="the-technical-difference">
  ## La diffÃ©rence sur le plan technique
</div>

<div id="rag-semantic-similarity">
  ### RAGÂ : similaritÃ© sÃ©mantique
</div>

```
RequÃªte â†’ Embedding â†’ Recherche vectorielle â†’ RÃ©sultats Top-K â†’ LLM
```

RAG excelle Ã  trouver des informations sÃ©mantiquement similaires Ã  votre requÃªte. Il est stateless â€” chaque requÃªte est indÃ©pendante.


<div id="memory-contextual-graph">
  ### MemoryÂ : graphe contextuel
</div>

```
RequÃªte â†’ Reconnaissance d'entitÃ©s â†’ Parcours de graphe â†’ Filtrage temporel â†’ Assemblage de contexte â†’ LLM
```

Les systÃ¨mes de memory construisent un graphe de connaissances qui comprendÂ :

* **EntitÃ©s**Â : utilisateurs, produits, concepts
* **Relations**Â : prÃ©fÃ©rences, propriÃ©tÃ©, causalitÃ©
* **Contexte temporel**Â : Ã  quel moment les faits Ã©taient vrais
* **Invalidation**Â : Ã  partir de quand les faits sont devenus obsolÃ¨tes


<div id="when-to-use-each">
  ## Quand utiliser chacun
</div>

<CardGroup cols={2}>
  <Card title="Ã€ utiliser avec RAG" icon="search">
    - Documentation statique
    - Bases de connaissances
    - RequÃªtes de recherche
    - Questions-rÃ©ponses gÃ©nÃ©rales
    - Contenu qui ne varie pas selon lâ€™utilisateur
  </Card>

  <Card title="Ã€ utiliser avec Memory" icon="brain">
    - PrÃ©fÃ©rences utilisateur
    - Historique de conversation
    - Faits personnels
    - SchÃ©mas comportementaux
    - Tout ce qui Ã©volue au fil du temps
  </Card>
</CardGroup>

<div id="real-world-examples">
  ## Exemples concrets
</div>

<div id="e-commerce-assistant">
  ### Assistant e-commerce
</div>

<Tabs>
  <Tab title="RAG Component">
    Stocke des catalogues de produits, des fiches techniques, des avis

    ```python
    # AdaptÃ© au RAG
    "Quelles sont les spÃ©cifications de lâ€™iPhone 15 ?"
    "Comparer des chaussures de running Nike et Adidas"
    "Montre-moi des vestes impermÃ©ables"
    ```
  </Tab>

  <Tab title="Memory Component">
    Suit les prÃ©fÃ©rences des utilisateurs, lâ€™historique dâ€™achats, les interactions

    ```python
    # NÃ©cessite la Memory
    "Quelle taille est-ce que je porte habituellement ?"
    "Ai-je apprÃ©ciÃ© mon dernier achat ?"
    "Quel est mon budget de prÃ©dilection ?"
    ```
  </Tab>
</Tabs>

<div id="customer-support-bot">
  ### Bot dâ€™assistance client
</div>

<Tabs>
  <Tab title="Composant RAG">
    documents de FAQ, guides de dÃ©pannage, politiques

    ```python
    # IdÃ©al pour RAG
    "Comment rÃ©initialiser mon mot de passe ?"
    "Quelle est votre politique de retour ?"
    "DÃ©pannage des problÃ¨mes de Wiâ€‘Fi"
    ```
  </Tab>

  <Tab title="Composant Memory">
    problÃ¨mes prÃ©cÃ©dents, dÃ©tails du compte utilisateur, contexte de conversation

    ```python
    # NÃ©cessite Memory
    "Mon problÃ¨me de la semaine derniÃ¨re est-il rÃ©solu ?"
    "Quel forfait aiâ€‘je ?"
    "Vous mâ€™aidiez Ã  propos de..."
    ```
  </Tab>
</Tabs>

<div id="how-supermemory-handles-both">
  ## Comment Supermemory gÃ¨re les deux
</div>

Supermemory propose une plateforme unifiÃ©e qui prend correctement en charge les deux modÃ¨lesÂ :

<div id="1-document-storage-rag">
  ### 1. Stockage de documents (RAG)
</div>

```python
# Ajouter un document pour la rÃ©cupÃ©ration de type RAG
client.memories.add(
    content="L'iPhone 15 a un appareil photo de 48 MP et une puce A17 Pro",
    # Aucune association utilisateur - connaissance universelle
)
```


<div id="2-memory-creation">
  ### 2. CrÃ©ation de memory
</div>

```python
# Ajouter une memory spÃ©cifique Ã  l'utilisateur
client.memories.add(
    content="L'utilisateur prÃ©fÃ¨re Android Ã  iOS",
    container_tags=["user_123"],  # SpÃ©cifique Ã  l'utilisateur
    metadata={
        "type": "preference",
        "confidence": "high"
    }
)
```


<div id="3-hybrid-retrieval">
  ### 3. Recherche hybride
</div>

```python
# La recherche combine les deux approches
results = client.memories.search(
    query="Quel tÃ©lÃ©phone devrais-je recommander ?",
    container_tags=["user_123"],  # RÃ©cupÃ¨re les memories de l'utilisateur
    # Recherche aussi dans les connaissances gÃ©nÃ©rales
)

# Les rÃ©sultats incluent :
# - La prÃ©fÃ©rence Android de l'utilisateur (memory)
# - Les spÃ©cifications des derniers tÃ©lÃ©phones Android (documents)
```


<div id="the-bottom-line">
  ## Lâ€™essentiel
</div>

<Note>
**IdÃ©e clÃ©** : RAG rÃ©pond Â« Quâ€™est-ce que je sais ? Â», tandis que memory rÃ©pond Â« Quâ€™est-ce que je me souviens Ã  ton sujet ? Â»
</Note>

Cessez de traiter la memory comme un problÃ¨me de recherche. Vos agents ont besoin des deux :

- **RAG** pour accÃ©der aux connaissances
- **Memory** pour comprendre les utilisateurs

Supermemory offre ces deux capacitÃ©s sur une plateforme unifiÃ©e, garantissant Ã  vos agents le bon contexte au bon moment.